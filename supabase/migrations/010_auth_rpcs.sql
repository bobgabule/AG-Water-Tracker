-- =============================================================================
-- Migration 010: Create atomic RPCs for auth operations
-- =============================================================================
-- This migration creates SECURITY DEFINER functions for auth-related operations.
-- These functions bypass RLS to perform atomic operations that involve multiple
-- tables and require elevated privileges.
-- =============================================================================

-- =============================================================================
-- Helper function: Generate random alphanumeric code
-- =============================================================================
-- Generates a random 6-character alphanumeric code for invite codes.
-- Excludes ambiguous characters (0, O, I, l, 1) for readability.
-- =============================================================================

CREATE OR REPLACE FUNCTION generate_random_code(p_length INTEGER DEFAULT 6)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
    -- Alphanumeric characters excluding ambiguous ones (0, O, I, l, 1)
    chars TEXT := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    result TEXT := '';
    i INTEGER;
BEGIN
    FOR i IN 1..p_length LOOP
        result := result || substr(chars, floor(random() * length(chars) + 1)::int, 1);
    END LOOP;
    RETURN result;
END;
$$;

COMMENT ON FUNCTION generate_random_code IS 'Generates a random alphanumeric code of specified length';

-- =============================================================================
-- RPC 1: create_farm_and_membership
-- =============================================================================
-- Creates a new farm and adds the calling user as the owner.
-- This is an atomic operation that ensures both records are created together.
--
-- Parameters:
--   p_farm_name: Name of the farm to create (required)
--   p_whim_number: Optional WHIM number for the farm
--
-- Returns: UUID of the created farm
-- =============================================================================

CREATE OR REPLACE FUNCTION create_farm_and_membership(
    p_farm_name TEXT,
    p_whim_number TEXT DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_user_id UUID;
    v_farm_id UUID;
BEGIN
    -- Get the current user's ID
    v_user_id := auth.uid();

    -- Verify user is authenticated
    IF v_user_id IS NULL THEN
        RAISE EXCEPTION 'Not authenticated';
    END IF;

    -- Check if user already owns a farm (optional business rule)
    -- Commented out to allow users to create multiple farms if needed
    -- IF EXISTS (SELECT 1 FROM farm_members WHERE user_id = v_user_id AND role = 'owner') THEN
    --     RAISE EXCEPTION 'User already owns a farm';
    -- END IF;

    -- Create the farm
    -- Note: invite_code is auto-generated by the set_invite_code trigger from migration 001
    INSERT INTO farms (name, description)
    VALUES (p_farm_name, p_whim_number)
    RETURNING id INTO v_farm_id;

    -- Create farm membership with owner role
    INSERT INTO farm_members (farm_id, user_id, role)
    VALUES (v_farm_id, v_user_id, 'owner');

    RETURN v_farm_id;
END;
$$;

COMMENT ON FUNCTION create_farm_and_membership IS 'Atomically creates a farm and adds the calling user as owner';

-- =============================================================================
-- RPC 2: join_farm_with_code
-- =============================================================================
-- Allows a user to join a farm using an invite code.
-- Validates the invite code and creates a farm membership.
--
-- Parameters:
--   p_code: The 6-character invite code
--
-- Returns: UUID of the farm that was joined
--
-- Errors:
--   - Invalid or expired invite code
--   - Invite code has reached maximum uses
--   - User is already a member of the farm
-- =============================================================================

CREATE OR REPLACE FUNCTION join_farm_with_code(p_code TEXT)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_user_id UUID;
    v_invite RECORD;
    v_farm_id UUID;
BEGIN
    -- Get the current user's ID
    v_user_id := auth.uid();

    -- Verify user is authenticated
    IF v_user_id IS NULL THEN
        RAISE EXCEPTION 'Not authenticated';
    END IF;

    -- Normalize the code to uppercase for case-insensitive matching
    p_code := UPPER(TRIM(p_code));

    -- First, try to find the invite code in the farm_invites table
    SELECT fi.farm_id, fi.role, fi.expires_at, fi.max_uses, fi.uses_count
    INTO v_invite
    FROM farm_invites fi
    WHERE fi.code = p_code;

    -- If found in farm_invites, validate and use it
    IF v_invite.farm_id IS NOT NULL THEN
        -- Check if invite has expired
        IF v_invite.expires_at < now() THEN
            RAISE EXCEPTION 'Invite code has expired';
        END IF;

        -- Check if invite has reached max uses
        IF v_invite.max_uses IS NOT NULL AND v_invite.uses_count >= v_invite.max_uses THEN
            RAISE EXCEPTION 'Invite code has reached maximum uses';
        END IF;

        v_farm_id := v_invite.farm_id;

        -- Check if user is already a member of this farm
        IF EXISTS (SELECT 1 FROM farm_members WHERE farm_id = v_farm_id AND user_id = v_user_id) THEN
            RAISE EXCEPTION 'You are already a member of this farm';
        END IF;

        -- Create farm membership with role from invite
        INSERT INTO farm_members (farm_id, user_id, role)
        VALUES (v_farm_id, v_user_id, v_invite.role);

        -- Increment uses count
        UPDATE farm_invites
        SET uses_count = uses_count + 1
        WHERE code = p_code;

        RETURN v_farm_id;
    END IF;

    -- Fallback: Check the farms table for legacy invite codes
    SELECT id INTO v_farm_id
    FROM farms
    WHERE invite_code = p_code;

    IF v_farm_id IS NULL THEN
        RAISE EXCEPTION 'Invalid invite code';
    END IF;

    -- Check if user is already a member of this farm
    IF EXISTS (SELECT 1 FROM farm_members WHERE farm_id = v_farm_id AND user_id = v_user_id) THEN
        RAISE EXCEPTION 'You are already a member of this farm';
    END IF;

    -- Create farm membership with default 'member' role for legacy codes
    INSERT INTO farm_members (farm_id, user_id, role)
    VALUES (v_farm_id, v_user_id, 'member');

    RETURN v_farm_id;
END;
$$;

COMMENT ON FUNCTION join_farm_with_code IS 'Joins a farm using an invite code, creating a farm membership';

-- =============================================================================
-- RPC 3: create_invite_code
-- =============================================================================
-- Creates a new invite code for a farm.
-- Only owners and admins of the farm can create invite codes.
--
-- Parameters:
--   p_farm_id: UUID of the farm to create invite for
--   p_role: Role to assign (default: 'member')
--   p_expires_days: Number of days until expiration (default: 7)
--   p_max_uses: Maximum number of uses (default: NULL = unlimited)
--
-- Returns: The generated invite code
--
-- Errors:
--   - User is not an owner or admin of the farm
--   - Invalid role specified
-- =============================================================================

CREATE OR REPLACE FUNCTION create_invite_code(
    p_farm_id UUID,
    p_role TEXT DEFAULT 'member',
    p_expires_days INTEGER DEFAULT 7,
    p_max_uses INTEGER DEFAULT NULL
)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_user_id UUID;
    v_user_role TEXT;
    v_code TEXT;
    v_attempts INTEGER := 0;
    v_max_attempts INTEGER := 10;
BEGIN
    -- Get the current user's ID
    v_user_id := auth.uid();

    -- Verify user is authenticated
    IF v_user_id IS NULL THEN
        RAISE EXCEPTION 'Not authenticated';
    END IF;

    -- Validate role parameter
    IF p_role NOT IN ('admin', 'member') THEN
        RAISE EXCEPTION 'Invalid role. Must be ''admin'' or ''member''';
    END IF;

    -- Validate expires_days
    IF p_expires_days <= 0 THEN
        RAISE EXCEPTION 'Expiration days must be positive';
    END IF;

    -- Validate max_uses
    IF p_max_uses IS NOT NULL AND p_max_uses <= 0 THEN
        RAISE EXCEPTION 'Max uses must be positive or NULL for unlimited';
    END IF;

    -- Check if user is an owner or admin of the farm
    SELECT role INTO v_user_role
    FROM farm_members
    WHERE farm_id = p_farm_id AND user_id = v_user_id;

    IF v_user_role IS NULL THEN
        RAISE EXCEPTION 'You are not a member of this farm';
    END IF;

    IF v_user_role NOT IN ('owner', 'admin') THEN
        RAISE EXCEPTION 'Only owners and admins can create invite codes';
    END IF;

    -- Generate a unique code (with retry logic for collision handling)
    LOOP
        v_code := generate_random_code(6);
        v_attempts := v_attempts + 1;

        -- Check if code already exists in farm_invites
        IF NOT EXISTS (SELECT 1 FROM farm_invites WHERE code = v_code) THEN
            -- Also check if it conflicts with any farm's legacy invite_code
            IF NOT EXISTS (SELECT 1 FROM farms WHERE invite_code = v_code) THEN
                EXIT; -- Found a unique code
            END IF;
        END IF;

        IF v_attempts >= v_max_attempts THEN
            RAISE EXCEPTION 'Failed to generate unique invite code after % attempts', v_max_attempts;
        END IF;
    END LOOP;

    -- Insert the invite code
    INSERT INTO farm_invites (code, farm_id, role, expires_at, max_uses, created_by)
    VALUES (
        v_code,
        p_farm_id,
        p_role,
        now() + (p_expires_days || ' days')::INTERVAL,
        p_max_uses,
        v_user_id
    );

    RETURN v_code;
END;
$$;

COMMENT ON FUNCTION create_invite_code IS 'Creates a new invite code for a farm (owner/admin only)';

-- =============================================================================
-- RPC 4: get_onboarding_status
-- =============================================================================
-- Returns the onboarding status for the current user.
-- Used to determine which step of the onboarding flow to show.
--
-- Returns: JSON object with:
--   - has_profile: boolean (user exists in users table)
--   - has_farm_membership: boolean (user has at least one farm_members entry)
--   - farm_id: string|null (first farm_id if user has membership, null otherwise)
-- =============================================================================

CREATE OR REPLACE FUNCTION get_onboarding_status()
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_user_id UUID;
    v_has_profile BOOLEAN;
    v_has_farm_membership BOOLEAN;
    v_farm_id UUID;
BEGIN
    -- Get the current user's ID
    v_user_id := auth.uid();

    -- Verify user is authenticated
    IF v_user_id IS NULL THEN
        RAISE EXCEPTION 'Not authenticated';
    END IF;

    -- Check if user has a profile in the users table
    SELECT EXISTS (
        SELECT 1 FROM users WHERE id = v_user_id
    ) INTO v_has_profile;

    -- Check if user has any farm memberships and get the first farm_id
    SELECT fm.farm_id INTO v_farm_id
    FROM farm_members fm
    WHERE fm.user_id = v_user_id
    ORDER BY fm.created_at ASC
    LIMIT 1;

    v_has_farm_membership := v_farm_id IS NOT NULL;

    -- Return the status as JSON
    RETURN json_build_object(
        'has_profile', v_has_profile,
        'has_farm_membership', v_has_farm_membership,
        'farm_id', v_farm_id
    );
END;
$$;

COMMENT ON FUNCTION get_onboarding_status IS 'Returns onboarding status for determining registration flow step';

-- =============================================================================
-- Helper RPC: get_user_farm_memberships
-- =============================================================================
-- Returns all farm memberships for the current user.
-- Useful for the UI to display farm selection or current farm info.
--
-- Returns: JSON array of farm membership objects
-- =============================================================================

CREATE OR REPLACE FUNCTION get_user_farm_memberships()
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_user_id UUID;
    v_result JSON;
BEGIN
    -- Get the current user's ID
    v_user_id := auth.uid();

    -- Verify user is authenticated
    IF v_user_id IS NULL THEN
        RAISE EXCEPTION 'Not authenticated';
    END IF;

    -- Get all farm memberships with farm details
    SELECT COALESCE(json_agg(
        json_build_object(
            'id', fm.id,
            'farm_id', fm.farm_id,
            'farm_name', f.name,
            'role', fm.role,
            'created_at', fm.created_at
        ) ORDER BY fm.created_at ASC
    ), '[]'::json)
    INTO v_result
    FROM farm_members fm
    JOIN farms f ON f.id = fm.farm_id
    WHERE fm.user_id = v_user_id;

    RETURN v_result;
END;
$$;

COMMENT ON FUNCTION get_user_farm_memberships IS 'Returns all farm memberships for the current user';
