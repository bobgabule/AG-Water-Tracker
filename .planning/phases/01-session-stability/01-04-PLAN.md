---
phase: 01-session-stability
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/AuthProvider.tsx
  - src/components/RequireOnboarded.tsx
  - src/components/AppLayout.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "After OTP verification, app resolves to dashboard or onboarding within 3 seconds without flashing 'Something went wrong' error UI"
    - "Component crash in a page shows error boundary with retry while Header and SideMenu navigation remain visible and functional"
  artifacts:
    - path: "src/lib/AuthProvider.tsx"
      provides: "isFetchingOnboarding flag in auth context"
      contains: "isFetchingOnboarding"
    - path: "src/components/RequireOnboarded.tsx"
      provides: "Loading state while onboarding RPC is in-flight instead of error UI"
      contains: "isFetchingOnboarding"
    - path: "src/components/AppLayout.tsx"
      provides: "ErrorBoundary wrapping only Outlet, not Header/SideMenu"
      contains: "ErrorBoundary"
  key_links:
    - from: "src/lib/AuthProvider.tsx"
      to: "src/components/RequireOnboarded.tsx"
      via: "isFetchingOnboarding in useAuth()"
      pattern: "isFetchingOnboarding"
    - from: "src/components/AppLayout.tsx"
      to: "src/components/ErrorFallback.tsx"
      via: "ErrorBoundary FallbackComponent wrapping only Outlet"
      pattern: "ErrorBoundary.*Outlet"
---

<objective>
Fix two UAT-diagnosed gaps: (1) brief "Something went wrong" flash during auth initialization when onboarding RPC is still in-flight, and (2) error boundary covering entire page including navigation instead of just the page content area.

Purpose: Eliminate false error states during normal auth flow, and ensure component crashes preserve navigation so users can recover without a full reload.
Output: Modified AuthProvider with fetch tracking, updated RequireOnboarded that distinguishes fetching from failed, and scoped ErrorBoundary in AppLayout.
</objective>

<execution_context>
@C:/Users/Bobits/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bobits/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-session-stability/01-01-SUMMARY.md
@.planning/phases/01-session-stability/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add isFetchingOnboarding flag to AuthProvider and update RequireOnboarded</name>
  <files>src/lib/AuthProvider.tsx, src/components/RequireOnboarded.tsx</files>
  <action>
In AuthProvider.tsx:
1. Add a new state: `const [isFetchingOnboarding, setIsFetchingOnboarding] = useState(false);`
2. In the `handleAuthStateChange` callback, for the INITIAL_SESSION, SIGNED_IN, and USER_UPDATED cases where `fetchOnboardingStatus()` is called:
   - Set `setIsFetchingOnboarding(true)` before the `Promise.race` call
   - Set `setIsFetchingOnboarding(false)` after setOnboardingStatus (in a finally or after the await)
3. Also in `verifyOtp`, wrap the `fetchOnboardingStatus()` call with `setIsFetchingOnboarding(true/false)`.
4. Add `isFetchingOnboarding` to the `AuthContextType` interface.
5. Add `isFetchingOnboarding` to the context value object.

In RequireOnboarded.tsx:
1. Destructure `isFetchingOnboarding` from `useAuth()`.
2. Change the condition at line 39 from `if (!onboardingStatus && session)` (which shows error/retry UI) to FIRST check: `if (!onboardingStatus && session && isFetchingOnboarding)` -- show the loading spinner (same as the !isAuthReady spinner), NOT the error UI. This is the "still fetching" state.
3. THEN check: `if (!onboardingStatus && session && !isFetchingOnboarding)` -- show the existing retry UI. This is the "fetch completed but failed" state.
4. This eliminates the brief flash of error UI during normal auth initialization because the fetch-in-progress state shows a spinner instead of "Something went wrong".

Important: The isFetchingOnboarding flag must be set to true BEFORE the async call begins and false AFTER it completes, including in error paths. Use try/finally pattern around the Promise.race calls.
  </action>
  <verify>
Run `npx tsc -b --noEmit` -- zero errors.
Verify `isFetchingOnboarding` appears in AuthContextType interface, context value, and is used in RequireOnboarded.tsx.
  </verify>
  <done>
RequireOnboarded shows a loading spinner (not error UI) while onboarding status RPC is in-flight. Error/retry UI only appears after the fetch has actually failed. No "Something went wrong" flash during normal auth flow.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scope ErrorBoundary in AppLayout to wrap only Outlet</name>
  <files>src/components/AppLayout.tsx</files>
  <action>
In AppLayout.tsx, restructure the component so that:

1. The ErrorBoundary wraps ONLY the `<Outlet />` (page content), NOT the Header, SideMenu, or PowerSyncProvider.
2. Keep PowerSyncProvider as the outermost wrapper (it needs to wrap everything for data access).
3. The resulting structure should be:

```
AppLayout() returns:
  <PowerSyncProvider>
    <AppLayoutContent />
  </PowerSyncProvider>

AppLayoutContent() returns:
  <div className="min-h-screen bg-gray-900">
    <Header farmName={farmName} onMenuOpen={handleMenuOpen} />
    <SideMenu open={menuOpen} onClose={handleMenuClose} />
    <main>
      <ErrorBoundary FallbackComponent={ErrorFallback}>
        <Outlet />
      </ErrorBoundary>
    </main>
  </div>
```

This means when a page component crashes, the ErrorFallback renders inside `<main>` while Header and SideMenu remain visible and functional. The user can navigate away from the crashed page using the navigation.

Do NOT add `onReset` or `resetKeys` to this ErrorBoundary -- the route-level boundary should reset on navigation, which react-error-boundary handles via the `key` from React Router context. If needed for navigation-based reset, add `resetKeys={[location.pathname]}` using `useLocation()` from react-router.
  </action>
  <verify>
Run `npx tsc -b --noEmit` -- zero errors.
Verify that in AppLayout.tsx, ErrorBoundary is inside AppLayoutContent wrapping only Outlet, while Header and SideMenu are siblings outside the ErrorBoundary.
  </verify>
  <done>
When a page component crashes, Header and SideMenu remain visible and functional. Error fallback renders only in the main content area. Navigation works during error state, allowing users to recover by navigating to a different page.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with zero errors
2. AuthProvider exports `isFetchingOnboarding` in its context type
3. RequireOnboarded checks `isFetchingOnboarding` before showing error UI
4. AppLayout ErrorBoundary wraps only Outlet, not Header/SideMenu
5. No other behavioral changes to auth flow or error handling
</verification>

<success_criteria>
- Auth flow during OTP verification shows spinner during onboarding fetch, never flashes error UI
- Page crashes preserve Header and SideMenu navigation
- TypeScript compiles cleanly
- All existing error boundary behavior (retry, friendly UI) preserved
</success_criteria>

<output>
After completion, create `.planning/phases/01-session-stability/01-04-SUMMARY.md`
</output>
