---
phase: 01-session-stability
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/powersync.ts
  - src/lib/PowerSyncContext.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "PowerSync database initialization failure shows friendly 'Something went wrong' retry UI instead of dead-end 'Database initialization failed' error"
    - "User can tap 'Try again' on database init failure and the app reattempts PowerSync initialization"
    - "WASM files load from service worker cache when offline because PowerSync runs in main thread (not SharedWorker)"
  artifacts:
    - path: "src/lib/powersync.ts"
      provides: "PowerSync database with useWebWorker:false flag for reliable offline WASM loading"
      contains: "useWebWorker"
    - path: "src/lib/PowerSyncContext.tsx"
      provides: "Retry mechanism for PowerSync database initialization failure"
      contains: "handleRetry"
  key_links:
    - from: "src/lib/powersync.ts"
      to: "@journeyapps/wa-sqlite"
      via: "WASM loaded in main thread via useWebWorker:false, ensuring service worker intercepts the request"
      pattern: "useWebWorker.*false"
    - from: "src/lib/PowerSyncContext.tsx"
      to: "src/lib/powersync.ts"
      via: "setupPowerSync() called on retry"
      pattern: "setupPowerSync"
---

<objective>
Fix the root cause of offline WASM loading failure AND replace the dead-end error screen with a friendly retry UI.

Purpose: UAT Test 3 found that offline reload fails with "Database initialization failed" because the wa-sqlite WASM file fails to load. Investigation reveals the WASM is loaded inside a SharedWorker by default, and SharedWorker fetch requests may not be intercepted by the service worker cache. Setting `useWebWorker: false` forces WASM loading in the main thread where service worker interception is guaranteed. The retry UI provides a graceful recovery path if initialization still fails for any reason.
Output: Modified powersync.ts with useWebWorker:false flag, modified PowerSyncContext.tsx with retry mechanism.
</objective>

<execution_context>
@C:/Users/Bobits/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bobits/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-session-stability/01-01-SUMMARY.md
@.planning/phases/01-session-stability/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure PowerSync to load WASM in main thread for reliable offline caching</name>
  <files>src/lib/powersync.ts</files>
  <action>
In `src/lib/powersync.ts`, modify the `PowerSyncDatabase` constructor (lines 15-19) to add the `flags` option with `useWebWorker: false`.

**Root cause context:** By default, `@powersync/web` opens SQLite inside a SharedWorker (`useWebWorker: true`). The SharedWorker dynamically imports the wa-sqlite `.mjs` chunk, which in turn fetches `wa-sqlite-async.wasm`. While Vite correctly rewrites the WASM URL to the hashed `/assets/` path in production builds, fetch requests originating from a SharedWorker context may not be intercepted by the service worker cache in all browsers. Setting `useWebWorker: false` forces the WASM to load in the main thread, where the service worker is guaranteed to intercept the fetch and serve from precache when offline.

Change the constructor from:
```ts
const db = new PowerSyncDatabase({
  schema: AppSchema,
  database: {
    dbFilename: 'ag-water-tracker.db',
  },
});
```

To:
```ts
const db = new PowerSyncDatabase({
  schema: AppSchema,
  database: {
    dbFilename: 'ag-water-tracker.db',
  },
  flags: {
    useWebWorker: false,
  },
});
```

**Why this is safe:**
- `useWebWorker: false` is explicitly supported by `@powersync/web` for the default `IDBBatchAtomicVFS` VFS (the only VFS that supports it).
- The wa-sqlite async module is designed for main-thread usage (uses async IDB operations, not synchronous OPFS).
- For a water tracker app with simple queries, the performance impact of running SQLite in the main thread is negligible.
- This is the same approach recommended for environments where web workers are unstable (per the SDK's own documentation of the `useWebWorker` flag).

Do NOT change anything else in this file. The singleton pattern, connector setup, debug logging, and disconnect logic remain unchanged.
  </action>
  <verify>
Run `npx tsc -b --noEmit` -- zero errors.
Verify that:
- `flags: { useWebWorker: false }` is present in the PowerSyncDatabase constructor options
- No other changes to the file
- The import for PowerSyncDatabase still comes from `@powersync/web`
  </verify>
  <done>
PowerSyncDatabase is configured with `useWebWorker: false`, ensuring WASM files load in the main thread where service worker cache interception is guaranteed for offline support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add retry mechanism to PowerSync database initialization failure UI</name>
  <files>src/lib/PowerSyncContext.tsx</files>
  <action>
In PowerSyncContext.tsx, replace the current dead-end error state (lines 74-83) with a retry-capable error UI:

1. Add a `retryCount` state to force the useEffect to re-run: `const [retryCount, setRetryCount] = useState(0);`
2. Add `retryCount` to the useEffect dependency array so incrementing it triggers a re-initialization attempt.
3. In the useEffect, when starting a retry, reset state to loading: at the top of the effect, call `setState({ db: null, loading: true, error: null });`
4. Add an `isRetrying` state for button feedback: `const [isRetrying, setIsRetrying] = useState(false);`
5. Replace the error UI block (the div with "Database initialization failed") with the same friendly pattern used elsewhere in the app:

```tsx
if (state.error) {
  const handleRetry = () => {
    setIsRetrying(true);
    // Reset the PowerSync singleton so it can be re-initialized
    // (setupPowerSync returns cached instance if already created)
    setRetryCount(c => c + 1);
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-900">
      <div className="text-center">
        <ArrowPathIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
        <p className="text-white font-medium mb-2">Something went wrong</p>
        <p className="text-gray-400 text-sm mb-6">
          We couldn't initialize the database
        </p>
        <button
          onClick={handleRetry}
          disabled={isRetrying}
          className="px-6 py-2 bg-green-500 hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg font-medium text-white transition-colors"
        >
          {isRetrying ? (
            <span className="flex items-center gap-2">
              <span className="animate-spin h-4 w-4 border-2 border-white border-t-transparent rounded-full" />
              Retrying...
            </span>
          ) : (
            'Tap to try again'
          )}
        </button>
      </div>
    </div>
  );
}
```

6. Import `ArrowPathIcon` from `@heroicons/react/24/outline`.
7. In the useEffect, clear `isRetrying` when the attempt completes (both success and failure): add `setIsRetrying(false)` in both `.then()` and `.catch()` callbacks.

IMPORTANT: The `setupPowerSync()` function in `powersync.ts` caches the singleton (`powerSyncInstance`). If init fails, the singleton is NOT set (the error is thrown before `powerSyncInstance = db`), so calling `setupPowerSync()` again will create a new attempt. No changes needed to `powersync.ts` for the retry mechanism.

8. Also ensure the useEffect resets loading state at the beginning when retryCount changes, so the loading spinner shows during retry.

The no-technical-details pattern: The subtitle says "We couldn't initialize the database" (friendly, not technical). Do NOT show `state.error.message` to the user. This matches the decision from 01-CONTEXT.md: "No technical details, approachable language."
  </action>
  <verify>
Run `npx tsc -b --noEmit` -- zero errors.
Verify that:
- ArrowPathIcon is imported
- Error state renders retry button with "Tap to try again"
- No `state.error.message` is displayed to user
- retryCount in useEffect dependency array
- isRetrying state provides button feedback
  </verify>
  <done>
PowerSync database initialization failure shows friendly retry UI matching established app patterns. User can tap to retry. No technical error details exposed. Loading spinner shows during retry attempt.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with zero errors
2. `src/lib/powersync.ts` has `flags: { useWebWorker: false }` in PowerSyncDatabase constructor
3. PowerSyncContext error state shows "Something went wrong" with retry button
4. No `state.error.message` exposed to user
5. Retry triggers re-initialization attempt with loading spinner
6. UI matches existing retry patterns (ArrowPathIcon, green button, isRetrying spinner)
</verification>

<success_criteria>
- WASM loads in main thread (useWebWorker: false) ensuring service worker cache works offline
- Database init failure shows friendly retry UI instead of dead-end error
- Retry button triggers new initialization attempt
- UI is consistent with other error/retry screens in the app
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-session-stability/01-05-SUMMARY.md`
</output>
