---
phase: 15-well-editing-allocation-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/032_well_edit_allocation_schema.sql
  - src/lib/powersync-schema.ts
  - src/lib/usage-calculation.ts
  - src/lib/validation.ts
  - src/stores/wellEditDraftStore.ts
autonomous: true
requirements:
  - ALLOC-05
  - EDIT-01

must_haves:
  truths:
    - "PowerSync allocations table has starting_reading column"
    - "Wells UPDATE/DELETE RLS allows any farm member (not just admin)"
    - "Usage calculation converts raw meter values to acre-feet using unit and multiplier"
    - "Well name and WMIS uniqueness validation can be checked locally"
    - "Well edit form draft state survives navigation to allocations page"
  artifacts:
    - path: "supabase/migrations/032_well_edit_allocation_schema.sql"
      provides: "starting_reading column + relaxed wells RLS"
      contains: "starting_reading"
    - path: "src/lib/powersync-schema.ts"
      provides: "Updated allocations table definition"
      contains: "starting_reading"
    - path: "src/lib/usage-calculation.ts"
      provides: "AF conversion and usage calculation"
      exports: ["calculateUsageAf", "getMultiplierValue", "CONVERSION_TO_AF"]
    - path: "src/lib/validation.ts"
      provides: "Coordinate validation + well uniqueness validation"
      exports: ["getCoordinateValidationError", "isWellNameUnique", "isWmisUnique"]
    - path: "src/stores/wellEditDraftStore.ts"
      provides: "Zustand store for edit form draft persistence"
      exports: ["useWellEditDraftStore"]
  key_links:
    - from: "src/lib/usage-calculation.ts"
      to: "CONVERSION_TO_AF constants"
      via: "exports used by allocation page"
      pattern: "calculateUsageAf"
    - from: "src/stores/wellEditDraftStore.ts"
      to: "well edit form"
      via: "Zustand store keyed by well ID"
      pattern: "useWellEditDraftStore"
---

<objective>
Create the foundational schema changes, utility functions, and stores needed by the well edit form and allocation management page.

Purpose: Establish the data layer (starting_reading column, relaxed RLS policies), business logic (usage calculation with unit conversion), validation (name/WMIS uniqueness), and state persistence (draft store for form round-trip) that Plans 02 and 03 depend on.

Output: Migration file, updated PowerSync schema, usage calculation utility, enhanced validation, and Zustand draft store.
</objective>

<execution_context>
@C:/Users/Kis&Co/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Kis&Co/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-well-editing-allocation-management/15-RESEARCH.md
@.planning/phases/15-well-editing-allocation-management/15-CONTEXT.md
@src/lib/powersync-schema.ts
@src/lib/validation.ts
@src/stores/toastStore.ts
@src/hooks/useWellAllocations.ts
@supabase/migrations/031_create_readings_and_allocations.sql
@supabase/migrations/017_create_wells_table.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Supabase migration and PowerSync schema update</name>
  <files>supabase/migrations/032_well_edit_allocation_schema.sql, src/lib/powersync-schema.ts</files>
  <action>
Create migration `032_well_edit_allocation_schema.sql` with two changes:

1. **Add `starting_reading` column to allocations table:**
   ```sql
   ALTER TABLE allocations ADD COLUMN starting_reading NUMERIC(15,2);
   COMMENT ON COLUMN allocations.starting_reading IS 'Baseline meter reading value for usage calculation within this allocation period';
   ```
   Type is `NUMERIC(15,2)` matching the `readings.value` type from migration 031.

2. **Relax wells UPDATE and DELETE RLS policies:**
   Per user decision "anyone with well access can edit and delete":
   ```sql
   DROP POLICY IF EXISTS "Owners and admins can update wells" ON wells;
   DROP POLICY IF EXISTS "Owners and admins can delete wells" ON wells;

   CREATE POLICY "Members can update wells"
       ON wells FOR UPDATE
       USING (farm_id IN (SELECT get_user_farm_ids()));

   CREATE POLICY "Members can delete wells"
       ON wells FOR DELETE
       USING (farm_id IN (SELECT get_user_farm_ids()));
   ```
   This matches the pattern already used for INSERT (migration 018) and allocations (migration 031).

Then update `src/lib/powersync-schema.ts`:
- Add `starting_reading: column.text` to the `allocations` TableV2 definition, placed after `is_manual_override` and before `notes`. Store as TEXT to preserve decimal precision (matching `allocated_af`, `used_af`, `value` pattern).
  </action>
  <verify>Run `npx tsc -b --noEmit` to confirm no type errors. Visually verify the migration file has both ALTER TABLE and DROP/CREATE POLICY statements. Verify `powersync-schema.ts` has `starting_reading` in the allocations table.</verify>
  <done>Migration 032 exists with starting_reading column addition and relaxed wells UPDATE/DELETE RLS policies. PowerSync allocations schema includes starting_reading as column.text.</done>
</task>

<task type="auto">
  <name>Task 2: Usage calculation utility, validation additions, and draft store</name>
  <files>src/lib/usage-calculation.ts, src/lib/validation.ts, src/stores/wellEditDraftStore.ts</files>
  <action>
**1. Create `src/lib/usage-calculation.ts`:**

Export these:
- `CONVERSION_TO_AF` constant: `{ AF: 1, GAL: 1/325851, CF: 1/43560 }` — conversion factors from native units to acre-feet.
- `getMultiplierValue(multiplier: string): number` — returns numeric multiplier. If `multiplier === 'MG'` return `1_000_000`. Otherwise `parseFloat(multiplier) || 1`.
- `calculateUsageAf(latestReading: string, startingReading: string, multiplier: string, units: string): number` — Usage formula per user decision:
  ```
  diff = parseFloat(latestReading) - parseFloat(startingReading)
  if diff <= 0: return 0
  rawUsage = diff * getMultiplierValue(multiplier)
  return rawUsage * (CONVERSION_TO_AF[units] ?? 1)
  ```
  Returns usage in acre-feet as a number. Handle NaN inputs gracefully (treat as 0).

**2. Update `src/lib/validation.ts`:**

Add two async-like functions (but actually sync since they query PowerSync data passed in):
- `isWellNameUnique(name: string, farmWells: { id: string; name: string }[], excludeId?: string): boolean` — returns true if no other well in the array has the same name (case-insensitive trim comparison), excluding the well being edited.
- `isWmisUnique(wmis: string, farmWells: { id: string; wmisNumber: string | null }[], excludeId?: string): boolean` — same pattern for WMIS number. Empty WMIS values are always considered unique (don't validate blank).

Keep all existing exports unchanged.

**3. Create `src/stores/wellEditDraftStore.ts`:**

Zustand store following the `toastStore.ts` pattern. Purpose: persist form state when user navigates from edit form to allocations page and back.

```typescript
interface WellEditDraft {
  wellId: string;
  name: string;
  meterSerialNumber: string;
  wmisNumber: string;
  latitude: number;
  longitude: number;
  units: 'AF' | 'GAL' | 'CF';
  multiplier: '0.01' | '1' | '10' | '1000' | 'MG';
  sendMonthlyReport: boolean;
  batteryState: string;
  pumpState: string;
  meterStatus: string;
}

interface WellEditDraftState {
  draft: WellEditDraft | null;
  setDraft: (draft: WellEditDraft) => void;
  clearDraft: () => void;
}
```

Export `useWellEditDraftStore`. The store saves the entire form state keyed by the draft's wellId. `setDraft` replaces the draft. `clearDraft` sets draft to null. The edit page will call `setDraft` before navigating to allocations and read it back on mount.
  </action>
  <verify>Run `npx tsc -b --noEmit` to confirm no type errors. Verify `usage-calculation.ts` exports `calculateUsageAf`, `getMultiplierValue`, and `CONVERSION_TO_AF`. Verify `validation.ts` still exports existing functions plus new `isWellNameUnique` and `isWmisUnique`. Verify `wellEditDraftStore.ts` exports `useWellEditDraftStore`.</verify>
  <done>Usage calculation utility correctly converts readings to AF via multiplier and unit conversion. Validation module has well name and WMIS uniqueness checkers. Draft store persists form state across navigation.</done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with no errors
2. Migration 032 file exists with correct SQL
3. PowerSync schema allocations table has `starting_reading` column
4. `usage-calculation.ts` correctly calculates: 100 GAL reading - 50 starting * multiplier 1 = 50 GAL = 50/325851 AF
5. `validation.ts` uniqueness functions handle case-insensitive comparison and exclude-self
6. `wellEditDraftStore.ts` can set and clear draft state
</verification>

<success_criteria>
- Migration 032 adds `starting_reading` to allocations and relaxes wells UPDATE/DELETE RLS to all farm members
- PowerSync schema includes `starting_reading: column.text` on allocations
- `calculateUsageAf()` correctly converts reading differences through multiplier and unit to AF
- `isWellNameUnique()` and `isWmisUnique()` check against farm wells excluding the current well
- `useWellEditDraftStore` persists and clears form draft state
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-well-editing-allocation-management/15-01-SUMMARY.md`
</output>
