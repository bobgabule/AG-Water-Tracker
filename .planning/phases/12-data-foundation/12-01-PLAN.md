---
phase: 12-data-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/031_create_readings_and_allocations.sql
  - src/lib/powersync-schema.ts
  - src/lib/powersync-connector.ts
  - docs/powersync-sync-rules.yaml
autonomous: true
requirements:
  - WELL-05
  - WELL-06
  - WELL-07
  - READ-01
  - READ-03
  - READ-05
  - READ-06
  - READ-07
  - ALLOC-01
  - ALLOC-02
  - ALLOC-03
  - ALLOC-04
  - ALLOC-05
  - ALLOC-06
  - PROX-02

must_haves:
  truths:
    - "A readings table exists in Supabase with well_id, farm_id (denormalized), value (NUMERIC), recorded_by, recorded_at, GPS coordinates, is_in_range, and RLS policies enforcing farm-level access via farm_id"
    - "An allocations table exists in Supabase with well_id, farm_id (denormalized), period_start, period_end, allocated_af, used_af, is_manual_override, and RLS policies enforcing farm-level access via farm_id"
    - "BEFORE INSERT triggers auto-populate farm_id from wells.farm_id on both readings and allocations"
    - "PowerSync local database includes readings and allocations tables with farm_id and correct column types (text for values, integer for booleans)"
    - "PowerSync connector uploads offline-created readings and allocations to Supabase with boolean normalization"
    - "Sync rules documentation uses direct farm_id = bucket.farm_id filtering (no subqueries) for readings and allocations buckets"
  artifacts:
    - path: "supabase/migrations/031_create_readings_and_allocations.sql"
      provides: "readings and allocations tables with indexes, triggers, and RLS policies"
      contains: "CREATE TABLE"
    - path: "src/lib/powersync-schema.ts"
      provides: "PowerSync schema with readings and allocations tables, and type exports"
      contains: "readings"
    - path: "src/lib/powersync-connector.ts"
      provides: "Connector with readings and allocations in ALLOWED_TABLES and boolean normalization"
      contains: "readings"
    - path: "docs/powersync-sync-rules.yaml"
      provides: "Sync rules documentation for readings and allocations buckets"
      contains: "farm_readings"
  key_links:
    - from: "src/lib/powersync-schema.ts"
      to: "supabase/migrations/031_create_readings_and_allocations.sql"
      via: "Column names and types match between PowerSync schema and Supabase tables (including denormalized farm_id)"
      pattern: "well_id.*text.*farm_id.*text.*value.*text"
    - from: "src/lib/powersync-connector.ts"
      to: "supabase/migrations/031_create_readings_and_allocations.sql"
      via: "ALLOWED_TABLES includes readings and allocations, normalizeForSupabase converts booleans"
      pattern: "readings.*allocations"
    - from: "docs/powersync-sync-rules.yaml"
      to: "supabase/migrations/031_create_readings_and_allocations.sql"
      via: "Sync rules use direct farm_id = bucket.farm_id filtering matching the denormalized farm_id column"
      pattern: "farm_id = bucket.farm_id"
---

<objective>
Create the Supabase database tables for readings and allocations with RLS policies, update the PowerSync schema and connector to support offline sync for both tables, and document the sync rules.

Purpose: Establishes the data storage layer that all v2.0 features (Phases 13-16) depend on. Without these tables and sync infrastructure, no meter readings or allocation data can be stored or queried.

Output: Migration file, updated PowerSync schema with type exports, updated connector with upload support, updated sync rules documentation.
</objective>

<execution_context>
@C:/Users/Kis&Co/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Kis&Co/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/lib/powersync-schema.ts
@src/lib/powersync-connector.ts
@docs/powersync-sync-rules.yaml
@supabase/migrations/017_create_wells_table.sql
@supabase/migrations/011_new_rls_policies.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase migration for readings and allocations tables</name>
  <files>supabase/migrations/031_create_readings_and_allocations.sql</files>
  <action>
Create migration `supabase/migrations/031_create_readings_and_allocations.sql` with:

**readings table:**
- `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
- `well_id UUID NOT NULL REFERENCES wells(id) ON DELETE CASCADE`
- `farm_id UUID NOT NULL REFERENCES farms(id)` -- denormalized for PowerSync sync rules (direct `WHERE farm_id = bucket.farm_id` filtering, no subqueries)
- `value NUMERIC(15,2) NOT NULL` -- raw cumulative meter value (exact decimal in Supabase)
- `recorded_by UUID NOT NULL REFERENCES auth.users(id)`
- `recorded_at TIMESTAMPTZ NOT NULL DEFAULT NOW()`
- `gps_latitude NUMERIC(10,8)` -- nullable (GPS may be unavailable)
- `gps_longitude NUMERIC(11,8)` -- nullable
- `is_in_range BOOLEAN DEFAULT FALSE` -- computed at recording time
- `notes TEXT`
- `created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()`
- `updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()`

Indexes: `idx_readings_well_id (well_id)`, `idx_readings_farm_id (farm_id)`, `idx_readings_well_recorded_at (well_id, recorded_at DESC)`.

Trigger: reuse existing `update_updated_at_column()` function from migration 001.

**Trigger to auto-populate farm_id on readings INSERT:**
Create a trigger function `set_reading_farm_id()` that runs BEFORE INSERT on readings. It looks up `farm_id` from `public.wells` using `NEW.well_id` and sets `NEW.farm_id = (SELECT farm_id FROM public.wells WHERE id = NEW.well_id)`. This ensures farm_id is always consistent with the well's farm, even when clients don't send it. Use fully qualified `public.wells` reference (per project memory: trigger functions must use fully qualified references).

**allocations table:**
- `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
- `well_id UUID NOT NULL REFERENCES wells(id) ON DELETE CASCADE`
- `farm_id UUID NOT NULL REFERENCES farms(id)` -- denormalized for PowerSync sync rules (same pattern as readings)
- `period_start DATE NOT NULL`
- `period_end DATE NOT NULL`
- `allocated_af NUMERIC(10,2) NOT NULL CHECK (allocated_af > 0)` -- acre-feet
- `used_af NUMERIC(10,2) NOT NULL DEFAULT 0`
- `is_manual_override BOOLEAN NOT NULL DEFAULT FALSE`
- `notes TEXT`
- `created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()`
- `updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()`
- `CONSTRAINT allocations_period_valid CHECK (period_end > period_start)`

Indexes: `idx_allocations_well_id (well_id)`, `idx_allocations_farm_id (farm_id)`, `idx_allocations_period (well_id, period_start, period_end)`.

Trigger: reuse `update_updated_at_column()`.

**Trigger to auto-populate farm_id on allocations INSERT:**
Create a trigger function `set_allocation_farm_id()` that runs BEFORE INSERT on allocations. Same pattern as readings: `NEW.farm_id = (SELECT farm_id FROM public.wells WHERE id = NEW.well_id)`. Use fully qualified `public.wells` reference.

**RLS policies for readings (4 policies):**
- Enable RLS on readings
- SELECT: Members can view farm readings -- `farm_id IN (SELECT get_user_farm_ids())`
- INSERT: Members can create readings -- `farm_id IN (SELECT get_user_farm_ids())` using WITH CHECK
- UPDATE: Grower/admin only -- `farm_id IN (SELECT get_user_admin_farm_ids())` (v2.0 decision READ-05)
- DELETE: Grower/admin only -- `farm_id IN (SELECT get_user_admin_farm_ids())` (v2.0 decision READ-06)

**RLS policies for allocations (4 policies, v2.0 decision: anyone with well access can set allocations):**
- Enable RLS on allocations
- SELECT: `farm_id IN (SELECT get_user_farm_ids())`
- INSERT: `farm_id IN (SELECT get_user_farm_ids())` using WITH CHECK
- UPDATE: `farm_id IN (SELECT get_user_farm_ids())`
- DELETE: `farm_id IN (SELECT get_user_farm_ids())`

No overlap-prevention constraint on allocations (per research recommendation -- validate client-side in Phase 15). The `farm_id` column is denormalized from `wells.farm_id` to enable direct PowerSync sync rule filtering (PowerSync does not support subqueries in data queries -- see `docs/powersync-sync-rules.yaml` line 112). Auto-populated by BEFORE INSERT triggers.
  </action>
  <verify>
Run `npx tsc -b --noEmit` to confirm no TypeScript breakage from schema changes. Visually inspect the migration file for correct SQL syntax, verify all column names match the phase success criteria.
  </verify>
  <done>Migration file exists with both tables, indexes, triggers, and RLS policies. Column names and types match the phase success criteria exactly.</done>
</task>

<task type="auto">
  <name>Task 2: Update PowerSync schema, connector, and sync rules documentation</name>
  <files>src/lib/powersync-schema.ts, src/lib/powersync-connector.ts, docs/powersync-sync-rules.yaml</files>
  <action>
**PowerSync schema (`src/lib/powersync-schema.ts`):**

Add `readings` table definition after `wells`:
```
const readings = new TableV2({
  well_id: column.text,
  farm_id: column.text,         // denormalized for sync rules filtering
  value: column.text,           // TEXT preserves decimal precision (v2.0 decision)
  recorded_by: column.text,
  recorded_at: column.text,
  gps_latitude: column.real,
  gps_longitude: column.real,
  is_in_range: column.integer,  // 0/1 boolean (PowerSync has no BOOLEAN)
  notes: column.text,
  created_at: column.text,
  updated_at: column.text,
});
```

Add `allocations` table definition after `readings`:
```
const allocations = new TableV2({
  well_id: column.text,
  farm_id: column.text,         // denormalized for sync rules filtering
  period_start: column.text,
  period_end: column.text,
  allocated_af: column.text,    // TEXT preserves decimal precision
  used_af: column.text,         // TEXT preserves decimal precision
  is_manual_override: column.integer,  // 0/1 boolean
  notes: column.text,
  created_at: column.text,
  updated_at: column.text,
});
```

Add both to `AppSchema`: `readings, allocations` in the Schema constructor.

Add type exports: `export type ReadingRow = Database['readings'];` and `export type AllocationRow = Database['allocations'];`.

**PowerSync connector (`src/lib/powersync-connector.ts`):**

Add `'readings'` and `'allocations'` to the `ALLOWED_TABLES` Set.

Extend `normalizeForSupabase` with two new conversion cases:
- For `readings` table: if `is_in_range` key exists, convert to `Boolean(data.is_in_range)`. The `farm_id` field is passed through as-is (it's a UUID text, no conversion needed -- the Supabase BEFORE INSERT trigger will overwrite it with the correct value from wells.farm_id anyway).
- For `allocations` table: if `is_manual_override` key exists, convert to `Boolean(data.is_manual_override)`. Same farm_id pass-through.

**Sync rules documentation (`docs/powersync-sync-rules.yaml`):**

Add two new bucket definitions after `farm_wells`:

`farm_readings` bucket:
- parameters: `SELECT farm_id FROM farm_members WHERE user_id = request.user_id()`
- data: `SELECT id, well_id, farm_id, value, recorded_by, recorded_at, gps_latitude, gps_longitude, is_in_range, notes, created_at, updated_at FROM readings WHERE farm_id = bucket.farm_id`
- This matches the existing `farm_wells` pattern exactly (direct `bucket.<param>` filtering, no subqueries -- per docs/powersync-sync-rules.yaml implementation note #2)

`farm_allocations` bucket:
- parameters: `SELECT farm_id FROM farm_members WHERE user_id = request.user_id()`
- data: `SELECT id, well_id, farm_id, period_start, period_end, allocated_af, used_af, is_manual_override, notes, created_at, updated_at FROM allocations WHERE farm_id = bucket.farm_id`
- Same direct filtering pattern

Add implementation note about sync rules needing dashboard configuration and testing.
  </action>
  <verify>
Run `npx tsc -b --noEmit` to confirm no TypeScript errors. Verify that `ReadingRow` and `AllocationRow` types are exported from `powersync-schema.ts`. Verify `ALLOWED_TABLES` in connector includes 'readings' and 'allocations'. Verify sync rules YAML is valid.
  </verify>
  <done>PowerSync schema defines readings and allocations tables with correct column types (text for values, integer for booleans). Connector includes both tables in ALLOWED_TABLES and normalizes booleans. Sync rules documentation has farm_readings and farm_allocations buckets. `npx tsc -b --noEmit` passes.</done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with no errors
2. Migration file contains CREATE TABLE for both readings and allocations
3. Migration file contains RLS policies (8 total: 4 for readings, 4 for allocations)
4. PowerSync schema exports `ReadingRow` and `AllocationRow` types
5. Connector ALLOWED_TABLES contains 7 entries (5 existing + readings + allocations)
6. Sync rules YAML contains farm_readings and farm_allocations bucket definitions
</verification>

<success_criteria>
- readings and allocations tables defined in migration with all columns from phase success criteria, including denormalized farm_id with BEFORE INSERT triggers
- PowerSync schema has matching table definitions with farm_id and correct types (text for meter values, integer for booleans)
- Connector uploads readings and allocations with boolean normalization
- Sync rules documentation uses direct farm_id = bucket.farm_id filtering (no subqueries), matching the established farm_wells pattern
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-data-foundation/12-01-SUMMARY.md`
</output>
