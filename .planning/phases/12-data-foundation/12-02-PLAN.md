---
phase: 12-data-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 12-01
files_modified:
  - src/hooks/useWellReadings.ts
  - src/hooks/useWellAllocations.ts
  - src/lib/gps-proximity.ts
autonomous: true
requirements:
  - WELL-03
  - WELL-05
  - WELL-10
  - WELL-11
  - READ-03
  - READ-04
  - READ-07
  - PROX-01
  - PROX-02
  - ALLOC-02
  - ALLOC-05
  - ALLOC-06

must_haves:
  truths:
    - "useWellReadings(wellId) returns readings for a well sorted by recorded_at descending, with boolean is_in_range conversion"
    - "useWellAllocations(wellId) returns allocation periods for a well sorted by period_start descending"
    - "Both hooks return loading and error states, guard against null wellId with 'SELECT NULL WHERE 0'"
    - "getDistanceToWell returns distance in feet between user coordinates and well coordinates"
    - "isInRange returns true when distance is within 500 feet threshold"
    - "PROXIMITY_THRESHOLD_FEET is exported as a constant set to 500"
  artifacts:
    - path: "src/hooks/useWellReadings.ts"
      provides: "Query hook for well readings with memoized mapping"
      exports: ["useWellReadings", "Reading"]
      min_lines: 40
    - path: "src/hooks/useWellAllocations.ts"
      provides: "Query hook for well allocations with memoized mapping"
      exports: ["useWellAllocations", "Allocation"]
      min_lines: 40
    - path: "src/lib/gps-proximity.ts"
      provides: "GPS distance calculation and proximity checking utilities"
      exports: ["getDistanceToWell", "isInRange", "PROXIMITY_THRESHOLD_FEET"]
      min_lines: 20
  key_links:
    - from: "src/hooks/useWellReadings.ts"
      to: "src/lib/powersync-schema.ts"
      via: "Imports ReadingRow type for query typing"
      pattern: "import.*ReadingRow.*powersync-schema"
    - from: "src/hooks/useWellAllocations.ts"
      to: "src/lib/powersync-schema.ts"
      via: "Imports AllocationRow type for query typing"
      pattern: "import.*AllocationRow.*powersync-schema"
    - from: "src/lib/gps-proximity.ts"
      to: "@turf/distance"
      via: "Uses turf distance function with feet units"
      pattern: "import.*distance.*@turf/distance"
---

<objective>
Create the query hooks for reading and retrieving readings and allocations data, and the GPS proximity utility for distance calculation and range checking.

Purpose: These hooks and utilities are the API layer that all v2.0 UI components (Phases 13-16) will use to access readings/allocations data and check GPS proximity. Without them, no UI component can display or interact with the data foundation built in Plan 01.

Output: Two query hooks (`useWellReadings`, `useWellAllocations`) and one GPS utility module (`gps-proximity.ts`).
</objective>

<execution_context>
@C:/Users/Kis&Co/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Kis&Co/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-data-foundation/12-01-SUMMARY.md

@src/hooks/useWells.ts
@src/lib/powersync-schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useWellReadings and useWellAllocations query hooks</name>
  <files>src/hooks/useWellReadings.ts, src/hooks/useWellAllocations.ts</files>
  <action>
Install `@turf/distance` first: `npm install @turf/distance` (needed for Task 2, but install here to avoid partial states).

**useWellReadings hook (`src/hooks/useWellReadings.ts`):**

Follow the exact pattern from `src/hooks/useWells.ts`:

1. Define a `Reading` interface (camelCase, exported) with fields:
   - `id: string`
   - `wellId: string`
   - `farmId: string` -- denormalized from wells table
   - `value: string` -- kept as string (TEXT in PowerSync, parse to number only when calculating)
   - `recordedBy: string`
   - `recordedAt: string`
   - `gpsLatitude: number | null`
   - `gpsLongitude: number | null`
   - `isInRange: boolean` -- converted from INTEGER 0/1
   - `notes: string | null`
   - `createdAt: string`
   - `updatedAt: string`

2. Define a `ReadingRow` interface (snake_case, private) matching PowerSync schema column names. Use the `ReadingRow` type from `powersync-schema.ts` if it provides the right shape, otherwise define locally.

3. Export function `useWellReadings(wellId: string | null)`:
   - Guard: if `wellId` is null, use `'SELECT NULL WHERE 0'`
   - Query: `SELECT id, well_id, farm_id, value, recorded_by, recorded_at, gps_latitude, gps_longitude, is_in_range, notes, created_at, updated_at FROM readings WHERE well_id = ? ORDER BY recorded_at DESC`
   - Pass `[wellId]` as params when wellId is non-null
   - Use `useQuery<ReadingRow>(query, params)` from `@powersync/react`
   - Memoize with `useMemo`: map rows to `Reading[]`, converting `is_in_range` from `row.is_in_range === 1` to boolean, mapping `farm_id` to `farmId`
   - Return `{ readings, loading: isLoading, error }`

**useWellAllocations hook (`src/hooks/useWellAllocations.ts`):**

Same pattern:

1. Define an `Allocation` interface (camelCase, exported):
   - `id: string`
   - `wellId: string`
   - `farmId: string` -- denormalized from wells table
   - `periodStart: string`
   - `periodEnd: string`
   - `allocatedAf: string` -- kept as string (TEXT in PowerSync)
   - `usedAf: string` -- kept as string
   - `isManualOverride: boolean` -- converted from INTEGER 0/1
   - `notes: string | null`
   - `createdAt: string`
   - `updatedAt: string`

2. Define a matching row interface.

3. Export function `useWellAllocations(wellId: string | null)`:
   - Guard: if `wellId` is null, use `'SELECT NULL WHERE 0'`
   - Query: `SELECT id, well_id, farm_id, period_start, period_end, allocated_af, used_af, is_manual_override, notes, created_at, updated_at FROM allocations WHERE well_id = ? ORDER BY period_start DESC`
   - Memoize with `useMemo`, converting `is_manual_override` from integer to boolean, mapping `farm_id` to `farmId`
   - Return `{ allocations, loading: isLoading, error }`

Both hooks must import `useMemo` from `react` and `useQuery` from `@powersync/react`. Do NOT import `useAuth` -- these hooks take `wellId` as a parameter, not farm-level data.
  </action>
  <verify>
Run `npx tsc -b --noEmit` to confirm TypeScript compilation passes. Verify both hooks export their named function and interface types. Verify both use the `'SELECT NULL WHERE 0'` guard pattern. Verify both use `useMemo` for result mapping.
  </verify>
  <done>Both hooks exist, export their function and interface, use the guard query pattern, memoize results, and convert integer booleans to actual booleans. TypeScript compilation passes.</done>
</task>

<task type="auto">
  <name>Task 2: Create GPS proximity utility</name>
  <files>src/lib/gps-proximity.ts</files>
  <action>
Create `src/lib/gps-proximity.ts` with:

1. Import `distance` from `@turf/distance`.

2. Export constant `PROXIMITY_THRESHOLD_FEET = 500` with JSDoc comment: "500 feet (~152.4 meters). Global threshold for all wells. User decision: not configurable per-well."

3. Export interface `Coords` with `lat: number` and `lng: number` for user coordinates.

4. Export interface `WellCoords` with `latitude: number` and `longitude: number` for well coordinates (matching the existing `WellLocation` interface shape from `useWells.ts`).

5. Export function `getDistanceToWell(userCoords: Coords, wellCoords: WellCoords): number`:
   - Use `distance([userCoords.lng, userCoords.lat], [wellCoords.longitude, wellCoords.latitude], { units: 'feet' })`
   - Return the distance in feet
   - Note: @turf/distance accepts `Position` arrays as `[longitude, latitude]` order (GeoJSON convention)

6. Export function `isInRange(distanceFeet: number): boolean`:
   - Return `distanceFeet <= PROXIMITY_THRESHOLD_FEET`
   - Simple threshold check, no rounding
   - Takes pre-calculated distance (from `getDistanceToWell`), not raw coordinates

Keep the module pure (no React hooks, no side effects). These are utility functions consumed by UI components in Phases 13-14.
  </action>
  <verify>
Run `npx tsc -b --noEmit` to confirm TypeScript compilation passes. Verify the module exports `getDistanceToWell`, `isInRange`, and `PROXIMITY_THRESHOLD_FEET`. Verify `@turf/distance` is in `package.json` dependencies.
  </verify>
  <done>GPS proximity module exports all three items. `getDistanceToWell` uses @turf/distance with `{ units: 'feet' }`. `isInRange` compares against 500ft threshold. TypeScript compilation passes. `@turf/distance` is in package.json.</done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with no errors
2. `useWellReadings` accepts `wellId: string | null` and returns `{ readings: Reading[], loading: boolean, error }`
3. `useWellAllocations` accepts `wellId: string | null` and returns `{ allocations: Allocation[], loading: boolean, error }`
4. Both hooks use `'SELECT NULL WHERE 0'` guard for null wellId
5. Both hooks use `useMemo` for result mapping with `[data]` dependency
6. `getDistanceToWell` returns distance in feet using @turf/distance
7. `isInRange` returns boolean based on 500ft threshold
8. `PROXIMITY_THRESHOLD_FEET` equals 500
9. `@turf/distance` is listed in package.json dependencies
</verification>

<success_criteria>
- useWellReadings returns sorted readings with boolean conversion
- useWellAllocations returns sorted allocations with boolean conversion
- GPS proximity utility calculates distance in feet and checks 500ft threshold
- All three files pass TypeScript compilation
- @turf/distance installed as dependency
</success_criteria>

<output>
After completion, create `.planning/phases/12-data-foundation/12-02-SUMMARY.md`
</output>
