---
phase: 23-route-level-code-splitting-bundle-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/LazyErrorBoundary.tsx
  - src/components/PageLoader.tsx
  - src/App.tsx
  - vite.config.ts
  - index.html
autonomous: true
requirements:
  - SPLIT-01
  - SPLIT-02
  - SPLIT-03
  - SPLIT-04
  - ASSET-03

must_haves:
  truths:
    - "Auth pages load without downloading Mapbox GL JS or well management code"
    - "Every page component is wrapped in its own Suspense + error boundary"
    - "Chunk load failures show a user-friendly error card with retry and offline detection"
    - "Browser DevTools shows preconnect requests for Supabase, Mapbox CDN, Mapbox tiles API, and PowerSync before app JS executes"
    - "Mapbox GL JS is isolated in its own chunk, loaded only when map pages are visited"
  artifacts:
    - path: "src/components/LazyErrorBoundary.tsx"
      provides: "Per-route error boundary with ChunkLoadError detection, offline awareness, auto-reload loop prevention, and route-change reset"
      contains: "ChunkLoadError"
    - path: "src/components/PageLoader.tsx"
      provides: "Suspense fallback with fullScreen prop, 150ms delay, 300ms minimum display, fade transitions"
      contains: "fullScreen"
    - path: "src/App.tsx"
      provides: "Per-route Suspense + LazyErrorBoundary wrapping every lazy page, auth routes get fullScreen loader"
      contains: "LazyErrorBoundary"
    - path: "vite.config.ts"
      provides: "Readable chunk names (pages/dashboard-[hash].js pattern), Mapbox manual chunk"
      contains: "chunkFileNames"
    - path: "index.html"
      provides: "Preconnect + dns-prefetch hints for all external services"
      contains: "preconnect"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/LazyErrorBoundary.tsx"
      via: "wraps each lazy route in per-route error boundary keyed by route path"
      pattern: "LazyErrorBoundary.*routePath"
    - from: "src/App.tsx"
      to: "src/components/PageLoader.tsx"
      via: "Suspense fallback for each route, auth routes pass fullScreen=true"
      pattern: "Suspense.*fallback.*PageLoader"
    - from: "vite.config.ts"
      to: "build output"
      via: "manualChunks isolates mapbox-gl, chunkFileNames gives readable names"
      pattern: "manualChunks.*mapbox"
---

<objective>
Implement per-route code splitting infrastructure with error boundaries, loading states, chunk naming, and resource hints.

Purpose: Auth pages must never download Mapbox GL JS. Each page gets its own Suspense boundary and error boundary. Chunk load failures are handled gracefully. Resource hints eliminate DNS waterfalls.

Output: Enhanced LazyErrorBoundary, PageLoader with fullScreen prop, per-route Suspense in App.tsx, readable chunk names in Vite config, complete preconnect hints in index.html.
</objective>

<execution_context>
@C:/Users/Bobits/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bobits/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-route-level-code-splitting-bundle-optimization/23-CONTEXT.md
@src/App.tsx
@src/components/LazyErrorBoundary.tsx
@src/components/PageLoader.tsx
@src/components/AppLayout.tsx
@vite.config.ts
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance PageLoader and LazyErrorBoundary components</name>
  <files>
    src/components/PageLoader.tsx
    src/components/LazyErrorBoundary.tsx
  </files>
  <action>
**PageLoader.tsx** — Enhance in-place (do NOT rewrite from scratch). Add:

1. `fullScreen` prop (optional boolean, default `false`):
   - `fullScreen=true`: `min-h-screen` centered (current behavior — for auth pages)
   - `fullScreen=false` (default): `flex-1` centered within parent (for authenticated pages where header/side menu stay visible)
2. 150ms delay before showing spinner (avoids flicker on fast loads):
   - Use `useState(false)` + `useEffect` with 150ms setTimeout
   - Return `null` until delay expires
3. 300ms minimum display time once visible:
   - Track when spinner first appeared, ensure at least 300ms before component can unmount naturally (use `useEffect` cleanup to handle this — or simpler: just show the spinner; since Suspense controls unmount, the 300ms min is mainly about the delay preventing sub-150ms flickers)
   - Implementation note: The 150ms delay already prevents flicker. For 300ms min, track `visibleSince` timestamp; if the component is still mounted after delay fires, it stays visible naturally. The key UX improvement is the delay.
4. Fade in transition (~150ms opacity):
   - Use Tailwind `transition-opacity duration-150` with conditional `opacity-0`/`opacity-100` classes tied to the show state

Keep the existing spinner style: `h-12 w-12 animate-spin rounded-full border-4 border-green-500 border-t-transparent`.

**LazyErrorBoundary.tsx** — Enhance in-place. Transform into:

1. Accept `routePath` prop (string) — used as React key for auto-reset on route change. The PARENT (App.tsx) will set `key={routePath}` on the boundary instance.
2. Detect `ChunkLoadError` specifically in `componentDidCatch`:
   - Check `error.name === 'ChunkLoadError'` OR `error.message?.includes('Failed to fetch dynamically imported module')` OR `error.message?.includes('Loading chunk')` OR `error.message?.includes('Importing a module script failed')`
   - If ChunkLoadError: show "App updated — reloading..." message for ~1 second, then auto-reload
   - Auto-reload loop prevention: check `sessionStorage.getItem('chunk-reload-count')`; if >= 1, do NOT auto-reload, show the manual error card instead. On auto-reload, increment the counter. Clear counter on successful page load (add a useEffect in a small wrapper or clear in componentDidMount after successful render).
3. Detect offline state:
   - If `!navigator.onLine`: show "You appear to be offline. Check your connection and try again." with a manual Reload button
4. Default error state (not chunk error, not offline):
   - Show existing error card: "Something went wrong loading this page." + "Reload" button
   - Reload button calls `window.location.reload()`
5. Auto-retry import once silently before showing error:
   - In `componentDidCatch`, if it's a chunk error and no prior retry attempt, set state to trigger a re-render (which will re-attempt the lazy import). Track retry with `this.hasRetried` boolean. If retry also fails, show error UI.

Style all error cards consistently: centered card with `bg-gray-800 rounded-xl p-6 text-center` on `bg-gray-900` background. Green button for Reload matching existing style.
  </action>
  <verify>
    <automated>npx tsc -b --noEmit</automated>
    <manual>PageLoader renders spinner after delay; LazyErrorBoundary handles chunk errors vs offline vs generic errors</manual>
  </verify>
  <done>PageLoader has fullScreen prop with delay/fade behavior. LazyErrorBoundary detects ChunkLoadError, offline state, auto-retries once, and prevents reload loops.</done>
</task>

<task type="auto">
  <name>Task 2: Wire per-route Suspense and error boundaries in App.tsx, configure Vite chunks and resource hints</name>
  <files>
    src/App.tsx
    vite.config.ts
    index.html
  </files>
  <action>
**App.tsx** — Restructure Suspense and error boundary placement:

1. Remove the single global `<LazyErrorBoundary>` and `<Suspense>` wrapping ALL routes.
2. Create a helper component or inline wrapper that wraps each lazy page in its own `<LazyErrorBoundary key={routePath}>` + `<Suspense fallback={<PageLoader />}>`:
   - Auth routes (`/auth/phone`, `/auth/verify`): use `<PageLoader fullScreen />` as fallback
   - Authenticated routes (inside AppLayout): use `<PageLoader />` (default, content-area only)
   - `NoSubscriptionPage`: use `<PageLoader fullScreen />` (no app shell)
3. Each `<LazyErrorBoundary>` should have a unique `key` prop set to the route path string so React auto-resets the boundary on navigation. For example:
   ```tsx
   <Route path="/auth/phone" element={
     <LazyErrorBoundary key="/auth/phone">
       <Suspense fallback={<PageLoader fullScreen />}>
         <PhonePage />
       </Suspense>
     </LazyErrorBoundary>
   } />
   ```
4. For routes inside `<AppLayout>`, wrap each `<Route element={...}>` similarly but with `<PageLoader />` (no fullScreen).
5. Keep all existing route structure (RequireAuth, RequireOnboarded, RequireRole nesting) exactly as-is. Only change is: each leaf page element gets its own Suspense + error boundary wrapper.

**vite.config.ts** — Add readable chunk names:

1. Add `chunkFileNames` to `rollupOptions.output`:
   ```ts
   chunkFileNames(chunkInfo) {
     if (chunkInfo.name?.startsWith('pages/')) return 'assets/[name]-[hash].js';
     return 'assets/[name]-[hash].js';
   }
   ```
   Actually simpler: just set `chunkFileNames: 'assets/[name]-[hash].js'` (Rollup default includes the name).
2. Remove the `powersync` manual chunk (per CONTEXT.md decision: "Mapbox only — no manual chunking for PowerSync or Supabase"). Keep the existing mapbox manual chunk. Keep the vendor chunk as-is.
3. Remove the `if (id.includes('@powersync/') || id.includes('@journeyapps/wa-sqlite'))` block from manualChunks.

**index.html** — Add missing preconnect hint:

1. Current state: has preconnect for Supabase, PowerSync, api.mapbox.com.
2. Per CONTEXT.md: need to add Mapbox JS CDN. The Mapbox GL JS library is loaded from npm (bundled), not a CDN. But Mapbox tiles use subdomains like `*.tiles.mapbox.com`. Add preconnect for the tiles subdomain:
   ```html
   <link rel="preconnect" href="https://tiles.mapbox.com" crossorigin>
   <link rel="dns-prefetch" href="https://tiles.mapbox.com">
   ```
   Also add events endpoint (Mapbox telemetry):
   ```html
   <link rel="preconnect" href="https://events.mapbox.com" crossorigin>
   <link rel="dns-prefetch" href="https://events.mapbox.com">
   ```
   Note: The CONTEXT.md says "Mapbox JS CDN" but since Mapbox GL JS is bundled via npm (not loaded from CDN), the CDN preconnect isn't needed. The tiles and events domains ARE separate network requests at runtime. The decision is at Claude's discretion per CONTEXT.md — add tiles.mapbox.com and events.mapbox.com as the meaningful runtime external requests.
  </action>
  <verify>
    <automated>npx tsc -b --noEmit && npx vite build 2>&1 | findstr /C:"assets/" | findstr /C:".js"</automated>
    <manual>Verify build output shows readable chunk names (mapbox-[hash].js, vendor-[hash].js, page names). Check index.html has all preconnect hints. Check App.tsx has per-route Suspense boundaries.</manual>
  </verify>
  <done>Each lazy page has its own Suspense + error boundary. Auth pages use fullScreen loader. Vite produces readable chunk names with Mapbox isolated. index.html has complete preconnect/dns-prefetch hints for all external services. PowerSync manual chunk removed per decisions.</done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with zero errors
2. `npx vite build` succeeds and output shows separate mapbox chunk, vendor chunk, and individual page chunks
3. Auth pages (PhonePage, VerifyPage) are NOT in the same chunk as DashboardPage or MapView
4. index.html contains preconnect + dns-prefetch for: Supabase, PowerSync, api.mapbox.com, tiles.mapbox.com, events.mapbox.com
5. Each route in App.tsx has its own LazyErrorBoundary + Suspense wrapper
6. PageLoader accepts fullScreen prop; auth routes use fullScreen, app routes don't
</verification>

<success_criteria>
- Auth page chunk contains zero Mapbox GL JS code
- Mapbox GL JS exists as its own separate chunk
- All 13 pages are lazy-loaded with per-route Suspense and error boundaries
- Preconnect hints cover all external service domains
- Build produces readable chunk filenames
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/23-route-level-code-splitting-bundle-optimization/23-01-SUMMARY.md`
</output>
