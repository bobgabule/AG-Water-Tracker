---
phase: 02-offline-session-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/AuthProvider.tsx
  - src/lib/powersync-connector.ts
autonomous: true

must_haves:
  truths:
    - "User who previously logged in can open the app offline and see their dashboard with cached wells and map data"
    - "PowerSync connector retries on network errors and stops on permanent auth failures"
  artifacts:
    - path: "src/lib/AuthProvider.tsx"
      provides: "Onboarding status caching with offline fallback and sign-out cache clearing"
      contains: "ONBOARDING_CACHE_KEY"
    - path: "src/lib/powersync-connector.ts"
      provides: "Correct error semantics: throw for retryable, return null for permanent"
      contains: "AuthRetryableFetchError"
  key_links:
    - from: "src/lib/AuthProvider.tsx"
      to: "localStorage"
      via: "ONBOARDING_CACHE_KEY set/get/remove"
      pattern: "localStorage\\.(set|get|remove)Item.*ONBOARDING_CACHE_KEY"
    - from: "src/lib/powersync-connector.ts"
      to: "@supabase/supabase-js"
      via: "AuthRetryableFetchError import and instanceof check"
      pattern: "isAuthRetryableFetchError|AuthRetryableFetchError"
---

<objective>
Cache onboarding status in localStorage so the app can bypass the `fetchOnboardingStatus` RPC call when offline, and fix the PowerSync connector to properly distinguish network errors (retryable) from permanent auth failures (account revoked).

Purpose: Currently, offline users with a valid cached session hit a "Something went wrong" retry screen because the onboarding status RPC fails. The connector also throws for all auth errors, causing infinite retry loops for revoked accounts. These two fixes are the foundation of offline session resilience.

Output: Modified AuthProvider.tsx with localStorage caching, modified powersync-connector.ts with correct error semantics.
</objective>

<execution_context>
@C:/Users/Bobits/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bobits/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-offline-session-resilience/02-RESEARCH.md

Key source files:
@src/lib/AuthProvider.tsx
@src/lib/powersync-connector.ts
@src/components/RequireOnboarded.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add onboarding status caching with offline fallback</name>
  <files>src/lib/AuthProvider.tsx</files>
  <action>
Modify `fetchOnboardingStatus` in AuthProvider.tsx to cache successful results and fall back to cache on failure:

1. Add a constant at module level: `const ONBOARDING_CACHE_KEY = 'ag-onboarding-status';`

2. Modify `fetchOnboardingStatus` callback:
   - On successful RPC response, after building the `status` object, persist it: `localStorage.setItem(ONBOARDING_CACHE_KEY, JSON.stringify(status))`
   - Wrap the setItem in a try/catch (localStorage can be full -- non-critical failure)
   - In both the `if (error)` branch and the `catch` branch, before returning null, attempt to read from cache: `const cached = localStorage.getItem(ONBOARDING_CACHE_KEY)` and return `JSON.parse(cached)` if it exists
   - If cache read also fails (invalid JSON, null), return null as before

3. Modify `signOut` callback:
   - After clearing PowerSync and local state, add: `localStorage.removeItem(ONBOARDING_CACHE_KEY)` (wrapped in try/catch for safety)
   - Place this BEFORE the state setters so the cache is cleared even if state setting throws

4. Do NOT modify `verifyOtp` -- it already calls `fetchOnboardingStatus` which will cache on success.

5. Do NOT change the Promise.race timeout pattern in `handleAuthStateChange` -- the timeout + cache fallback work together (if RPC times out, the catch path will read cache).

Use `debugLog` from `./debugLog` for any new log statements (not console.log). Import it if not already imported (debugLog is already imported as debugError -- add debugLog to the existing import).
  </action>
  <verify>
Run `npx tsc -b --noEmit` -- no type errors.
Verify the cache key constant, setItem call, getItem fallback, and removeItem in signOut all exist by reading the file.
  </verify>
  <done>
fetchOnboardingStatus caches on success and falls back to cache on failure. signOut clears the cache. No type errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix connector error semantics for retryable vs permanent auth failures</name>
  <files>src/lib/powersync-connector.ts</files>
  <action>
Modify `fetchCredentials()` in powersync-connector.ts to properly distinguish error types:

1. Add import at the top: `import { isAuthRetryableFetchError } from '@supabase/supabase-js';`
   - Note: `isAuthRetryableFetchError` is a utility function exported by `@supabase/supabase-js` that checks if an error is an `AuthRetryableFetchError` (network errors, 502/503/504).

2. Replace the current `fetchCredentials()` implementation. The current code:
   ```
   if (!session) {
     const { data: { session: refreshed } } = await supabase.auth.refreshSession();
     if (!refreshed) {
       throw new Error('Not authenticated');
     }
     return { endpoint: ..., token: refreshed.access_token };
   }
   return { endpoint: ..., token: session.access_token };
   ```

   New implementation:
   ```typescript
   async fetchCredentials() {
     const { data: { session } } = await supabase.auth.getSession();

     if (session) {
       return {
         endpoint: import.meta.env.VITE_POWERSYNC_URL,
         token: session.access_token,
       };
     }

     // No session in memory -- try refreshing the token
     const { data: { session: refreshed }, error } = await supabase.auth.refreshSession();

     if (error) {
       if (isAuthRetryableFetchError(error)) {
         // Network/5xx error -- throw so PowerSync retries later
         throw error;
       }
       // Permanent auth failure (revoked token, invalid refresh token)
       // Return null to signal "not authenticated" -- PowerSync will stop connecting
       debugWarn('PowerSync', 'Permanent auth error in fetchCredentials:', error.message);
       return null;
     }

     if (!refreshed) {
       // No error but no session -- treat as not authenticated
       return null;
     }

     return {
       endpoint: import.meta.env.VITE_POWERSYNC_URL,
       token: refreshed.access_token,
     };
   }
   ```

   Key changes from current code:
   - Session-exists path stays the same (early return)
   - Capture `error` from `refreshSession()` instead of just checking `!refreshed`
   - Check `isAuthRetryableFetchError(error)` to throw for retryable (PowerSync retries)
   - Return `null` for permanent errors instead of throwing (PowerSync stops trying)
   - `null` return type is valid for `PowerSyncBackendConnector.fetchCredentials` -- it signals "not authenticated"

3. Update the return type: The `fetchCredentials` method should return `Promise<PowerSyncCredentials | null>`. Import `PowerSyncCredentials` from `@powersync/web` if not already imported. Check the existing type imports at the top of the file.
  </action>
  <verify>
Run `npx tsc -b --noEmit` -- no type errors.
Verify the file imports `isAuthRetryableFetchError` and uses it in the error check by reading the file.
  </verify>
  <done>
Connector throws for retryable errors (network/5xx), returns null for permanent errors (revoked token). No type errors. No more infinite retry loops for revoked accounts.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with zero errors
2. AuthProvider.tsx contains ONBOARDING_CACHE_KEY constant, localStorage.setItem in fetchOnboardingStatus, localStorage.getItem fallback in error paths, localStorage.removeItem in signOut
3. powersync-connector.ts imports isAuthRetryableFetchError, uses it in fetchCredentials, returns null for permanent errors, throws for retryable errors
</verification>

<success_criteria>
- App can open offline for a previously-authenticated user without hitting "Something went wrong" (onboarding status served from cache)
- PowerSync connector stops retrying when a user's account is permanently revoked
- PowerSync connector retries when the user is just temporarily offline
- Onboarding status cache is cleared on explicit sign-out
</success_criteria>

<output>
After completion, create `.planning/phases/02-offline-session-resilience/02-01-SUMMARY.md`
</output>
