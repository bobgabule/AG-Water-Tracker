---
phase: 02-offline-session-resilience
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/AuthProvider.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User whose account has been revoked sees 'Your session has expired. Please sign in again.' immediately on reload -- not 'Something went wrong'"
    - "Non-auth RPC errors (network failures, 5xx) still fall back to cache and show the retry UI"
    - "Cached onboarding data is NOT served when the session itself is invalid"
  artifacts:
    - path: "src/lib/AuthProvider.tsx"
      provides: "Auth error detection in fetchOnboardingStatus with immediate session expiry trigger"
      contains: "isAuthError"
  key_links:
    - from: "src/lib/AuthProvider.tsx fetchOnboardingStatus"
      to: "src/lib/AuthProvider.tsx sessionExpired state"
      via: "setSessionExpired(true) + setSession(null) + setUser(null) on auth RPC error"
      pattern: "setSessionExpired\\(true\\)"
---

<objective>
Fix the race condition where a revoked user sees "Something went wrong" instead of "Session expired" on app reload.

Purpose: UAT Test 2 failed because fetchOnboardingStatus treats all RPC errors identically -- auth errors (stale JWT rejected by server) fall back to cache or return null, which triggers RequireOnboarded's generic error UI. The Supabase SIGNED_OUT event fires too late (next event loop tick) to prevent this. The fix detects auth-related RPC errors in fetchOnboardingStatus and immediately triggers the session expiry flow, bypassing the cache fallback.

Output: Updated AuthProvider.tsx where auth RPC errors short-circuit to session expired UI.
</objective>

<execution_context>
@C:/Users/Bobits/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bobits/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-offline-session-resilience/02-01-SUMMARY.md
@.planning/phases/02-offline-session-resilience/02-02-SUMMARY.md
@.planning/debug/session-expired-not-showing.md
@src/lib/AuthProvider.tsx
@src/components/RequireAuth.tsx
@src/components/RequireOnboarded.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Detect auth errors in fetchOnboardingStatus and trigger immediate session expiry</name>
  <files>src/lib/AuthProvider.tsx</files>
  <action>
Modify fetchOnboardingStatus in AuthProvider.tsx to detect auth-related RPC errors and immediately trigger session expiry instead of falling back to cache. This is Option A1 from the debug session analysis.

**Step 1: Add an auth error detection helper inside fetchOnboardingStatus (or above it)**

Create an inline helper function `isAuthRpcError` that checks if a Supabase RPC error indicates an invalid/expired session:

```typescript
const isAuthRpcError = (error: { code?: string; message?: string }): boolean => {
  // PGRST301: JWT expired (PostgREST)
  if (error.code === 'PGRST301') return true;
  // HTTP 401 returned as error code string
  if (error.code === '401') return true;
  // JWT-related error messages from Supabase/PostgREST
  const msg = error.message?.toLowerCase() ?? '';
  if (msg.includes('jwt') || msg.includes('token') || msg.includes('expired') || msg.includes('invalid claim')) return true;
  return false;
};
```

Place this as a module-level function (above the AuthProvider component, below the types) so it stays outside the render cycle.

**Step 2: Modify the `if (error)` branch in fetchOnboardingStatus (currently lines 83-96)**

BEFORE the existing cache fallback logic, add an auth error check:

```typescript
if (error) {
  debugError('Auth', 'Failed to fetch onboarding status:', error);

  // Auth errors mean the session itself is invalid -- don't mask with cache
  if (isAuthRpcError(error)) {
    debugLog('Auth', 'RPC failed due to invalid session, triggering session expiry');
    setSessionExpired(true);
    setSession(null);
    setUser(null);
    setOnboardingStatus(null);
    // Clear the stale onboarding cache too
    try { localStorage.removeItem(ONBOARDING_CACHE_KEY); } catch { /* non-critical */ }
    return null;
  }

  // Non-auth errors: attempt to serve from cache (existing behavior)
  try {
    const cached = localStorage.getItem(ONBOARDING_CACHE_KEY);
    if (cached) {
      debugLog('Auth', 'Serving onboarding status from cache (RPC error)');
      return JSON.parse(cached) as OnboardingStatus;
    }
  } catch {
    // Cache read failed -- fall through
  }
  return null;
}
```

**Step 3: Modify the outer `catch (err)` branch (currently lines 115-128)**

Add the same auth error detection for thrown errors (not just returned errors). The RPC might throw rather than return an error object in some network conditions. Check if the thrown error has auth-related properties:

```typescript
catch (err) {
  debugError('Auth', 'Error fetching onboarding status:', err);

  // Check if the thrown error is auth-related
  const errObj = err as { code?: string; message?: string };
  if (isAuthRpcError(errObj)) {
    debugLog('Auth', 'RPC threw auth error, triggering session expiry');
    setSessionExpired(true);
    setSession(null);
    setUser(null);
    setOnboardingStatus(null);
    try { localStorage.removeItem(ONBOARDING_CACHE_KEY); } catch { /* non-critical */ }
    return null;
  }

  // Non-auth errors: attempt to serve from cache (existing behavior)
  try {
    const cached = localStorage.getItem(ONBOARDING_CACHE_KEY);
    if (cached) {
      debugLog('Auth', 'Serving onboarding status from cache (network error)');
      return JSON.parse(cached) as OnboardingStatus;
    }
  } catch {
    // Cache read failed -- fall through
  }
  return null;
}
```

**Step 4: Update fetchOnboardingStatus's useCallback dependency array**

Since fetchOnboardingStatus now calls setSessionExpired, setSession, setUser, and setOnboardingStatus, these are React state setters and are stable (do NOT need to be in the dependency array -- React guarantees setter identity stability). The isAuthRpcError helper is a module-level function, also stable. So the dependency array remains `[]`. No change needed here.

**What NOT to change:**
- Do NOT modify RequireAuth.tsx or RequireOnboarded.tsx -- the session expired UI already exists and works correctly once sessionExpired=true and session=null
- Do NOT modify the SIGNED_OUT handler -- it still needs to set sessionExpired for cases where the auto-refresh tick catches the revocation first
- Do NOT modify the PowerSync connector -- it already handles auth errors correctly
- Do NOT add network calls (like getUser()) -- this would break offline functionality
  </action>
  <verify>
1. Run `npx tsc -b --noEmit` -- zero TypeScript errors
2. Verify the isAuthRpcError function exists: `grep -n "isAuthRpcError" src/lib/AuthProvider.tsx`
3. Verify auth error detection in the error branch: `grep -n "setSessionExpired(true)" src/lib/AuthProvider.tsx` -- should appear at least 2 times in fetchOnboardingStatus (error branch + catch branch), plus the existing one in SIGNED_OUT handler
4. Verify cache fallback is preserved for non-auth errors: `grep -n "Serving onboarding status from cache" src/lib/AuthProvider.tsx` -- should still appear twice
5. Verify localStorage cleanup on auth error: `grep -n "removeItem.*ONBOARDING_CACHE_KEY" src/lib/AuthProvider.tsx` -- should appear 3 times (signOut + 2 auth error paths)
  </verify>
  <done>
- Auth RPC errors (401, PGRST301, JWT-related) in fetchOnboardingStatus immediately trigger setSessionExpired(true) + clear session/user/onboarding state
- Non-auth errors (network, 5xx) still fall back to localStorage cache (existing behavior preserved)
- Stale onboarding cache is cleared on auth errors so it cannot mask revocation on retry
- RequireAuth's existing session expired UI renders immediately because session=null and sessionExpired=true are set synchronously
  </done>
</task>

</tasks>

<verification>
**Manual UAT re-test (UAT Test 2):**
1. Sign in to the app normally, navigate to dashboard
2. In Supabase dashboard, delete the user's row from auth.sessions
3. Reload the app in the browser
4. EXPECTED: "Session Expired" screen with yellow warning icon and "Your session has expired. Please sign in again." message + "Sign In" button
5. NOT EXPECTED: "Something went wrong / We couldn't load your account info" retry screen

**Regression checks:**
- Normal sign-out still navigates to phone page with no expired message
- Offline user with cached data still sees dashboard (network errors hit cache path, not auth error path)
- Online user with valid session still loads normally
</verification>

<success_criteria>
1. UAT Test 2 passes: revoked user sees session expired UI on reload, not generic error
2. No regression on UAT Tests 1, 3, 4, 5 (offline dashboard, normal sign-out, offline OTP blocks)
3. TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-offline-session-resilience/02-03-SUMMARY.md`
</output>
