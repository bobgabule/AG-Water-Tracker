---
phase: 24-loading-state-collapse-skeleton-screens
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/index.css
  - src/components/skeletons/SkeletonPrimitives.tsx
  - src/lib/PowerSyncContext.tsx
  - src/components/AppLayout.tsx
  - src/lib/AuthProvider.tsx
autonomous: true
requirements: [LOAD-01, LOAD-02, LOAD-07]

must_haves:
  truths:
    - "Returning user with cached auth sees app shell (Header + SideMenu) within 300ms -- no full-screen spinner"
    - "PowerSync initializes in the background while the app shell is interactive"
    - "Sign-out returns user to login page in under 500ms with no visible freeze"
    - "Skeleton primitives render animated shimmer placeholders"
  artifacts:
    - path: "src/components/skeletons/SkeletonPrimitives.tsx"
      provides: "Reusable SkeletonLine, SkeletonBlock, SkeletonCircle components"
      min_lines: 40
    - path: "src/index.css"
      provides: "shimmer keyframe animation"
      contains: "@keyframes shimmer"
    - path: "src/lib/PowerSyncContext.tsx"
      provides: "Non-blocking PowerSync provider that renders children immediately"
    - path: "src/lib/AuthProvider.tsx"
      provides: "Fast sign-out with background cleanup"
  key_links:
    - from: "src/components/AppLayout.tsx"
      to: "src/lib/PowerSyncContext.tsx"
      via: "PowerSyncProvider renders children immediately (non-blocking)"
      pattern: "children"
    - from: "src/lib/AuthProvider.tsx"
      to: "/auth/phone"
      via: "signOut clears state immediately, runs PowerSync cleanup in background"
      pattern: "disconnectAndClear.*background"
---

<objective>
Create skeleton primitive components with shimmer animation, make PowerSync initialization non-blocking so the app shell renders immediately, and fix the sign-out delay.

Purpose: Returning users currently see a full-screen spinner while PowerSync initializes. After this plan, they see the app shell (Header + SideMenu) instantly with skeleton placeholders in the content area. Sign-out currently takes ~2 seconds due to PowerSync disconnect timeout; it should be under 500ms.

Output: Skeleton primitive components, shimmer CSS animation, non-blocking PowerSync provider, fast sign-out.
</objective>

<execution_context>
@C:/Users/Bobits/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bobits/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-loading-state-collapse-skeleton-screens/24-CONTEXT.md
@.planning/phases/23-route-level-code-splitting-bundle-optimization/23-01-SUMMARY.md
@src/lib/PowerSyncContext.tsx
@src/components/AppLayout.tsx
@src/lib/AuthProvider.tsx
@src/index.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skeleton primitives and shimmer animation</name>
  <files>src/index.css, src/components/skeletons/SkeletonPrimitives.tsx</files>
  <action>
1. Add shimmer keyframe animation to `src/index.css` inside a `@layer utilities` block:
   - `@keyframes shimmer` that moves a linear gradient from left to right
   - Background: `linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.4) 50%, transparent 100%)` at 200% width
   - Animation: `shimmer 1.5s infinite`
   - Create a utility class `.animate-shimmer` that applies this animation

2. Create `src/components/skeletons/SkeletonPrimitives.tsx` with three reusable components:

   **SkeletonLine** — Represents a text line placeholder
   - Props: `width?: string` (Tailwind width class, default 'w-full'), `height?: string` (default 'h-4')
   - Renders a `<div>` with `bg-gray-200 rounded` plus `relative overflow-hidden` with a shimmer overlay `<div>` inside using `absolute inset-0 animate-shimmer`
   - Rounded to match existing Tailwind `rounded` classes

   **SkeletonBlock** — Represents a rectangular area (map, card, image)
   - Props: `width?: string` (default 'w-full'), `height?: string` (default 'h-32'), `className?: string`
   - Same shimmer pattern as SkeletonLine but with configurable dimensions
   - Use `rounded-lg` for blocks (matching existing component rounding)

   **SkeletonCircle** — Represents a circular placeholder (avatars, FABs)
   - Props: `size?: string` (Tailwind size class, default 'w-10 h-10')
   - Uses `rounded-full` with shimmer overlay

   All components:
   - Accept optional `className` for additional styling
   - Include `aria-hidden="true"` on each element (decorative)
   - Colors: base `bg-gray-200` (subtle on white or light backgrounds per CONTEXT decisions)
   - Export all three as named exports

   Pattern for shimmer overlay inside each primitive:
   ```tsx
   <div className={`relative overflow-hidden bg-gray-200 ${roundingClass} ${sizeClasses} ${className}`} aria-hidden="true">
     <div className="absolute inset-0 animate-shimmer" />
   </div>
   ```
  </action>
  <verify>
    <automated>npx tsc -b --noEmit</automated>
    <manual>Verify SkeletonPrimitives.tsx exports three named components and index.css contains shimmer keyframe</manual>
  </verify>
  <done>Three skeleton primitive components (SkeletonLine, SkeletonBlock, SkeletonCircle) exist with shimmer animation, CSS keyframe is defined in index.css</done>
</task>

<task type="auto">
  <name>Task 2: Non-blocking PowerSync provider and fast sign-out</name>
  <files>src/lib/PowerSyncContext.tsx, src/components/AppLayout.tsx, src/lib/AuthProvider.tsx</files>
  <action>
1. **Refactor PowerSyncContext.tsx** to be non-blocking:

   Current behavior: `PowerSyncProvider` shows `PowerSyncLoadingScreen` (full-screen spinner) while `setupPowerSync()` runs, blocking all children from rendering.

   New behavior: Render children IMMEDIATELY while PowerSync initializes in the background. Expose loading/error state via context so children can show skeletons or handle errors themselves.

   Changes:
   - Remove the `PowerSyncLoadingScreen` component entirely
   - Remove the early-return loading/error screens from `PowerSyncProvider`
   - Instead, ALWAYS render children. When `state.loading` is true, still render children but wrap them in `InternalContext.Provider` with `{ db: null, loading: true, error: null }`
   - When `state.error` is set and `state.db` is null, still render children (the error retry UI will be handled by a new inline component within the provider that overlays or is rendered alongside children)
   - Actually: the cleanest approach is to ALWAYS render the `PSContext.Provider` with a `db` value (use a placeholder/null-safe approach) AND the children. But since `@powersync/react` hooks like `useQuery` require a valid `PowerSyncDatabase` in context, we need to be careful.

   **Recommended approach:**
   - Keep the `PSContext.Provider` wrapping children only when `state.db` is available
   - When `state.loading` or `state.error`, render children WITHOUT `PSContext.Provider` — but this means PowerSync hooks will throw. So instead:
   - Add a new exported hook `usePowerSyncReady(): { loading: boolean; error: Error | null; retry: () => void }` from the InternalContext
   - When `state.db` exists: render `<PSContext.Provider value={state.db}><InternalContext.Provider value={state}>{children}</InternalContext.Provider></PSContext.Provider>`
   - When `state.loading` or no db: render `<InternalContext.Provider value={state}>{children}</InternalContext.Provider>` WITHOUT `PSContext.Provider` (so hooks that use usePowerSync will need guards)

   **Simpler approach (preferred):** Keep existing structure but move blocking UI out:
   - The `PowerSyncProvider` currently blocks rendering with loading/error screens. Instead, always render children alongside a status overlay:
   - When loading: render `{children}` (app shell shows immediately). No loading screen.
   - When error with no db: render `{children}` plus an error overlay/modal that lets user retry. The children (pages) will show their skeletons since useQuery returns empty data when db is not connected yet.
   - When db ready: render as before with `PSContext.Provider`

   **Actually simplest correct approach:**
   - Create the PowerSync database instance synchronously (or immediately after mount) and set it in context right away, THEN connect asynchronously
   - PowerSync's `PowerSyncDatabase` can be created and provided to context before `connect()` is called. Queries will return empty until sync starts. This is the PowerSync recommended pattern for non-blocking init.
   - Modify `setupPowerSync()` (or inline in the provider) to: (a) create the database instance synchronously with `new PowerSyncDatabase(...)`, (b) provide it to context immediately, (c) call `connect()` asynchronously in background

   Check `src/lib/powersync.ts` for how `setupPowerSync()` works. If it does `new PowerSyncDatabase()` then `await db.init()` then `db.connect(connector)`, we can split this:
   - Phase 1 (sync): `new PowerSyncDatabase({ schema, database: { dbFilename } })` + `await db.init()` — this is fast (WASM + SQLite init, already pre-warmed in main.tsx)
   - Phase 2 (async/background): `db.connect(connector)` — this does network sync, can be slow

   Provide the db after Phase 1, let Phase 2 run in background. Children get a working (but empty) local database immediately.

   If `setupPowerSync()` bundles init + connect together, refactor it to return the db after init, and expose a separate `connectPowerSync(db)` function.

   Update the PowerSyncProvider to:
   ```tsx
   // Phase 1: init db quickly (WASM already pre-warmed)
   const db = await initPowerSync(); // fast
   setState({ db, loading: false, error: null });
   // Phase 2: connect in background (slow network)
   connectPowerSync(db).catch(err => debugError('PowerSync', 'Background connect failed:', err));
   ```

   Keep the error state for init failures (WASM load fail = critical), but connect failures should NOT block the UI.

   Export `usePowerSyncStatus` hook from PowerSyncContext.tsx:
   ```tsx
   export function usePowerSyncStatus(): { loading: boolean; error: Error | null } {
     const { loading, error } = useContext(InternalContext);
     return { loading, error };
   }
   ```

2. **Update AppLayout.tsx** — No changes needed if PowerSyncProvider now renders children immediately. The Header and SideMenu will render while PowerSync connects. But verify `useQuery` in AppLayoutContent (membership check) handles the case where PowerSync db exists but data hasn't synced yet — it should, since `useQuery` returns empty array when no data exists.

3. **Fix sign-out in AuthProvider.tsx** (LOAD-07):

   Current `signOut()`:
   ```tsx
   await supabase.auth.signOut();
   await Promise.race([disconnectAndClear(), new Promise(resolve => setTimeout(resolve, 2000))]);
   // ... clear state
   ```

   The 2-second timeout blocks the UI. Per CONTEXT decisions: "Instant redirect to login page on sign-out. PowerSync cleanup happens in background AFTER redirect."

   New `signOut()`:
   ```tsx
   const signOut = useCallback(async (): Promise<void> => {
     userInitiatedSignOut.current = true;

     // Clear local state IMMEDIATELY for instant redirect
     setSession(null);
     setUser(null);
     setAuthStatus(null);
     useActiveFarmStore.getState().clearOverride();
     try { localStorage.removeItem(AUTH_STATUS_CACHE_KEY); } catch { /* non-critical */ }

     // Background cleanup — no await, no blocking
     (async () => {
       try {
         await supabase.auth.signOut();
       } catch (error) {
         debugError('Auth', 'Sign out error:', error);
       }
       try {
         await disconnectAndClear();
       } catch (error) {
         debugError('Auth', 'Failed to clear PowerSync:', error);
       }
       userInitiatedSignOut.current = false;
     })();
   }, []);
   ```

   Key changes:
   - State clears FIRST (triggers instant redirect via RequireAuth)
   - `supabase.auth.signOut()` and `disconnectAndClear()` run in background IIFE
   - Remove the `Promise.race` 2-second timeout entirely
   - Per CONTEXT: "If background cleanup fails, ignore silently"
   - Set `userInitiatedSignOut.current = true` BEFORE clearing state to prevent SIGNED_OUT handler from firing session expiry
  </action>
  <verify>
    <automated>npx tsc -b --noEmit</automated>
    <manual>Check that PowerSyncProvider renders children immediately without loading screen, and signOut clears state before async cleanup</manual>
  </verify>
  <done>PowerSync initializes non-blocking (children render while db connects), sign-out clears state instantly with background cleanup. App shell (Header + SideMenu) visible immediately for returning users.</done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with zero errors
2. `npx vite build` produces successful build
3. `src/components/skeletons/SkeletonPrimitives.tsx` exports SkeletonLine, SkeletonBlock, SkeletonCircle
4. `src/index.css` contains `@keyframes shimmer`
5. PowerSyncProvider no longer has `PowerSyncLoadingScreen` or early-return loading states
6. `signOut()` in AuthProvider clears state before async cleanup
</verification>

<success_criteria>
- Skeleton primitives render with shimmer animation
- PowerSync provider renders children immediately (no blocking loading screen)
- Sign-out clears state instantly, PowerSync cleanup runs in background
- All TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/24-loading-state-collapse-skeleton-screens/24-01-SUMMARY.md`
</output>
