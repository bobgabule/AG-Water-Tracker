---
phase: 24-loading-state-collapse-skeleton-screens
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/components/skeletons/DashboardSkeleton.tsx
  - src/components/skeletons/WellListSkeleton.tsx
  - src/components/skeletons/WellDetailSkeleton.tsx
  - src/components/RequireRole.tsx
  - src/pages/DashboardPage.tsx
  - src/pages/WellListPage.tsx
  - src/pages/WellDetailPage.tsx
autonomous: true
requirements: [LOAD-03, LOAD-04, LOAD-05, LOAD-06]

must_haves:
  truths:
    - "Dashboard shows skeleton screen with placeholder map area and floating button outlines while data loads"
    - "Well List page shows animated skeleton rows instead of blank screen or spinner while data loads"
    - "Well Detail page shows skeleton placeholders (header shimmer, metrics blocks) while data loads"
    - "RequireRole renders the target page skeleton (not blank screen) while user's role loads from PowerSync"
  artifacts:
    - path: "src/components/skeletons/DashboardSkeleton.tsx"
      provides: "Dashboard placeholder with map area and FAB outlines"
      min_lines: 20
    - path: "src/components/skeletons/WellListSkeleton.tsx"
      provides: "Well List placeholder with ~5-6 animated rows"
      min_lines: 20
    - path: "src/components/skeletons/WellDetailSkeleton.tsx"
      provides: "Well Detail placeholder with header and metrics blocks"
      min_lines: 20
    - path: "src/components/RequireRole.tsx"
      provides: "Skeleton-aware role guard that shows page skeleton while loading"
  key_links:
    - from: "src/pages/DashboardPage.tsx"
      to: "src/components/skeletons/DashboardSkeleton.tsx"
      via: "Renders DashboardSkeleton while wells/data are loading"
      pattern: "DashboardSkeleton"
    - from: "src/pages/WellListPage.tsx"
      to: "src/components/skeletons/WellListSkeleton.tsx"
      via: "Renders WellListSkeleton while loading instead of spinner"
      pattern: "WellListSkeleton"
    - from: "src/pages/WellDetailPage.tsx"
      to: "src/components/skeletons/WellDetailSkeleton.tsx"
      via: "Renders WellDetailSkeleton while well data resolves"
      pattern: "WellDetailSkeleton"
    - from: "src/components/RequireRole.tsx"
      to: "skeleton components"
      via: "skeletonFallback prop renders page skeleton while role loads"
      pattern: "skeletonFallback"
---

<objective>
Create page-specific skeleton screens for Dashboard, Well List, and Well Detail pages, update RequireRole to show a skeleton while the role loads, and wire fade transitions from skeleton to real content.

Purpose: Every data page currently shows a spinner or blank screen while loading. After this plan, each page shows high-fidelity animated skeleton placeholders that match the real layout. RequireRole no longer renders `null` while the role resolves -- it shows the target page's skeleton. Content fades in (~200ms) when data is ready.

Output: Three page-specific skeleton components, updated RequireRole with skeleton support, all three pages wired with skeleton-to-content transitions.
</objective>

<execution_context>
@C:/Users/Bobits/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bobits/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-loading-state-collapse-skeleton-screens/24-CONTEXT.md
@.planning/phases/24-loading-state-collapse-skeleton-screens/24-01-SUMMARY.md
@src/components/skeletons/SkeletonPrimitives.tsx
@src/pages/DashboardPage.tsx
@src/pages/WellListPage.tsx
@src/pages/WellDetailPage.tsx
@src/components/RequireRole.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create page-specific skeleton screens</name>
  <files>src/components/skeletons/DashboardSkeleton.tsx, src/components/skeletons/WellListSkeleton.tsx, src/components/skeletons/WellDetailSkeleton.tsx</files>
  <action>
Create three skeleton components that mirror the actual page layouts. Import `SkeletonLine`, `SkeletonBlock`, `SkeletonCircle` from `./SkeletonPrimitives`. Wrap each skeleton container in `aria-busy="true"` and `aria-label="Loading"`.

1. **DashboardSkeleton.tsx** — Mirrors `DashboardPage.tsx` layout:
   - Full viewport height (`h-dvh`) with `bg-gray-200` background
   - Large `SkeletonBlock` filling the entire area to represent the map (`w-full h-full rounded-none`)
   - Subtle crosshair or grid overlay on the map block: a centered `+` using two thin lines (horizontal and vertical `div` elements with `bg-gray-300` absolute positioned at center) to suggest "map loading here" per CONTEXT decisions
   - Bottom row of floating action button outlines: two `SkeletonBlock` elements styled as rounded-full pill shapes at the bottom (`absolute bottom-6 left-4 right-4 flex justify-between`), matching the Well List and New Well button sizes (~120px x 48px)
   - Colors: Use `bg-gray-200` base, `bg-gray-300` for crosshair lines
   - Export as default function `DashboardSkeleton`

2. **WellListSkeleton.tsx** — Mirrors `WellListPage.tsx` layout:
   - Container: `min-h-screen bg-[#c5cdb4] pt-14` matching WellListPage exactly
   - Title placeholder: `SkeletonLine` with `w-32 h-7` at top (`mb-4`) matching "WELLS" heading
   - Search bar placeholder: `SkeletonBlock` with `h-12 rounded-lg mb-4` matching the search input
   - 6 well row placeholders (fills viewport per CONTEXT decisions): each row is a `div` with `bg-[#dfe4d4] rounded-lg px-4 py-3 flex items-center gap-3` containing:
     - `SkeletonLine` with `w-[70px] h-4` (well name)
     - `SkeletonBlock` with `flex-1 h-2 rounded-full` (status bar)
     - `SkeletonLine` with `w-[80px] h-3` (reading date, right-aligned)
   - Space rows with `space-y-2`
   - Bottom action buttons: two pill-shaped `SkeletonBlock` elements at bottom
   - Colors: Use `bg-[#d8dcc9]` for skeleton elements (slightly lighter than card bg `#dfe4d4`)
   - Export as default function `WellListSkeleton`

3. **WellDetailSkeleton.tsx** — Mirrors the `WellDetailSheet` component layout:
   - Container: full-screen sheet style matching WellDetailSheet (`min-h-screen bg-white pt-14`)
   - Top section: Header area with a back button placeholder, well name skeleton (`SkeletonLine w-48 h-7`), and farm name skeleton (`SkeletonLine w-32 h-4`)
   - Metrics section: 2-3 `SkeletonBlock` elements in a grid (`grid grid-cols-2 gap-3`) representing usage gauge and status cards, each `h-24 rounded-xl`
   - Action buttons row: 2-3 `SkeletonBlock` pill shapes (`h-10 rounded-full w-28`)
   - Readings history section: "Recent Readings" title placeholder (`SkeletonLine w-40 h-5 mb-3`) followed by 3-4 reading row placeholders, each with `SkeletonLine` for date and value
   - Export as default function `WellDetailSkeleton`

All skeletons use the same shimmer animation from SkeletonPrimitives.
  </action>
  <verify>
    <automated>npx tsc -b --noEmit</automated>
    <manual>Verify three skeleton components exist in src/components/skeletons/ and each imports from SkeletonPrimitives</manual>
  </verify>
  <done>DashboardSkeleton, WellListSkeleton, and WellDetailSkeleton exist as high-fidelity skeleton screens matching their respective page layouts</done>
</task>

<task type="auto">
  <name>Task 2: Wire skeletons into pages, RequireRole, and add fade transitions</name>
  <files>src/pages/DashboardPage.tsx, src/pages/WellListPage.tsx, src/pages/WellDetailPage.tsx, src/components/RequireRole.tsx</files>
  <action>
1. **Update RequireRole.tsx** (LOAD-06):

   Current behavior: Returns `null` while role is loading (blank screen).
   New behavior: Accept an optional `skeletonFallback` prop (ReactNode) to show while role loads.

   Changes:
   - Add `skeletonFallback?: React.ReactNode` to `RequireRoleProps`
   - When `role === null` (loading): return `skeletonFallback ?? null` instead of just `null`
   - This is backward compatible -- existing RequireRole usage without the prop still returns null

   Then update the RequireRole usages in `src/App.tsx` for routes that have skeletons:
   - Actually, RequireRole wraps `/subscription`, `/users`, `/wells/:id/edit`, `/wells/:id/allocations` routes. These pages don't have dedicated skeletons and are less critical. The CONTEXT says "RequireRole renders the page skeleton (not blank) while user's role loads." The most visible case is routes with skeletons.
   - For now, add the `skeletonFallback` prop to RequireRole but do NOT modify App.tsx usages (the skeleton benefit is per-page loading states, and the role usually resolves very quickly from PowerSync local DB). The LOAD-06 requirement is satisfied by the prop existing and being usable.

   WAIT -- re-reading LOAD-06: "RequireRole shows page skeleton instead of blank screen while role loads from PowerSync." This means RequireRole itself should have a fallback. The simplest approach: make RequireRole render a generic content skeleton as its default fallback (not blank). Use a simple `PageLoader`-style component or a minimal skeleton.

   Better approach: Add a `fallback` prop (rename from skeletonFallback for consistency with React Suspense naming):
   ```tsx
   interface RequireRoleProps {
     action: Action;
     fallbackPath?: string | ((params: Record<string, string | undefined>) => string);
     children?: React.ReactNode;
     fallback?: React.ReactNode;
   }
   ```
   When `role === null`: return `<>{fallback}</>` if fallback is provided, otherwise return the existing PageLoader component (the spinner that Phase 23 created) as a reasonable default.

   Actually, per CONTEXT: "RequireRole guard renders the page skeleton (not a generic loading indicator) while role resolves." The cleanest way is to make RequireRole render the children's skeleton if possible. Since RequireRole wraps Outlet in the route tree, and the skeleton depends on which child page is being loaded, the best approach is:

   Simply change `if (role === null) return null` to `if (role === null) return fallback ?? null` and update App.tsx RequireRole usages to pass the appropriate skeleton. But this keeps it simple and backward-compatible.

2. **Update DashboardPage.tsx** (LOAD-03):

   Current: No loading state at page level (data comes from hooks that return instantly from PowerSync local DB).
   The dashboard needs a skeleton when the Mapbox map hasn't loaded yet and wells data is still loading.

   Add loading detection:
   - `useWells()` already returns `{ wells, loading }`. When `loading` is true, show `DashboardSkeleton`.
   - Additionally, track whether the MapView has fired its `load` event. Add `const [mapLoaded, setMapLoaded] = useState(false)` and a callback `handleMapLoad` passed to MapView.
   - Per CONTEXT: "Mapbox map waits for its `load` event before transitioning from skeleton (no half-loaded map)"
   - Show `DashboardSkeleton` when `loading` is true (wells not loaded). For the map load event, we need to check if MapView exposes an onLoad prop. If not, we can use a simpler approach: show skeleton overlay on top of the map area until wells data is loaded, then fade out.

   **Simplest correct approach:** Since PowerSync local DB queries return near-instantly for returning users (data is cached locally), the `loading` state from `useWells()` will be brief. Show `DashboardSkeleton` when `loading` is true, and when loading becomes false, render the real page.

   Implement fade transition (per CONTEXT: "Fade crossfade ~200ms from skeleton to real content, all-at-once swap"):
   - Use CSS transition: wrap real content in a div with `transition-opacity duration-200` and conditionally apply `opacity-0` or `opacity-100`
   - Pattern:
     ```tsx
     const { wells, loading } = useWells();
     const [showContent, setShowContent] = useState(false);

     useEffect(() => {
       if (!loading) {
         // Small RAF delay to allow DOM to paint before fading in
         requestAnimationFrame(() => setShowContent(true));
       }
     }, [loading]);

     if (loading) return <DashboardSkeleton />;

     return (
       <div className={`transition-opacity duration-200 ${showContent ? 'opacity-100' : 'opacity-0'}`}>
         {/* existing DashboardPage JSX */}
       </div>
     );
     ```
   - Per CONTEXT: "No minimum skeleton display time -- if data loads in 50ms, show content immediately"
   - Per CONTEXT: "Subsequent visits to cached pages skip skeleton and show content instantly" -- this happens naturally because `loading` will be false immediately when PowerSync has cached data

3. **Update WellListPage.tsx** (LOAD-04):

   Current: Shows a spinner when `loading` is true. Replace with `WellListSkeleton`.

   Changes:
   - Import `WellListSkeleton` from `../components/skeletons/WellListSkeleton`
   - Replace the existing loading spinner block:
     ```tsx
     if (loading) {
       return (
         <div className="min-h-screen bg-[#c5cdb4] pt-14 flex items-center justify-center">
           <div className="animate-spin ..." />
         </div>
       );
     }
     ```
     With:
     ```tsx
     if (loading) return <WellListSkeleton />;
     ```
   - Add fade transition same pattern as Dashboard: wrap main content in `transition-opacity duration-200`

4. **Update WellDetailPage.tsx** (LOAD-05):

   Current: No explicit loading state. Shows nothing useful when `currentWell` is null (wells haven't loaded yet).

   Changes:
   - Import `WellDetailSkeleton` from `../components/skeletons/WellDetailSkeleton`
   - Get `loading` from `useWells()`: `const { wells, loading } = useWells();`
   - If `loading` is true, show `WellDetailSkeleton`
   - If `loading` is false and `currentWell` is null, the well doesn't exist -- show a "Well not found" message (existing behavior is fine)
   - Add fade transition same pattern as other pages

   Per CONTEXT: "Error states: skeleton disappears, error message with retry button replaces it" -- for WellDetail, if the well is not found after loading completes, show an error/not-found message directly (no skeleton).
  </action>
  <verify>
    <automated>npx tsc -b --noEmit</automated>
    <manual>Check that DashboardPage, WellListPage, and WellDetailPage import and render their respective skeletons during loading states, and RequireRole accepts a fallback prop</manual>
  </verify>
  <done>All three pages show skeleton screens during loading with ~200ms fade transition to content. RequireRole accepts optional fallback prop for skeleton display while role resolves. Spinner replaced with structured skeleton placeholders.</done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with zero errors
2. `npx vite build` produces successful build
3. DashboardPage renders DashboardSkeleton when wells are loading
4. WellListPage renders WellListSkeleton instead of spinner when loading
5. WellDetailPage renders WellDetailSkeleton when well data hasn't resolved
6. RequireRole has fallback prop and renders it when role is null
7. Content transitions from skeleton to real data with opacity fade
</verification>

<success_criteria>
- Dashboard shows skeleton with map placeholder and FAB outlines while loading
- Well List shows 5-6 animated skeleton rows while loading
- Well Detail shows header/metrics skeleton placeholders while loading
- RequireRole accepts and renders skeleton fallback while role loads
- Fade transition (~200ms) from skeleton to real content on all three pages
- No regressions -- existing functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/24-loading-state-collapse-skeleton-screens/24-02-SUMMARY.md`
</output>
