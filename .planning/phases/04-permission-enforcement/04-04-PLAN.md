---
phase: 04-permission-enforcement
plan: 04
type: execute
wave: 3
depends_on: ["04-03"]
files_modified:
  - src/hooks/useRoleChangeDetector.ts
  - src/components/AppLayout.tsx
  - src/lib/AuthProvider.tsx
autonomous: true

must_haves:
  truths:
    - "When a user's role changes on the server, their local data refreshes and UI updates on next sync"
    - "Role change detection does NOT trigger on initial app load (no infinite reload loop)"
    - "Active farm store is cleared during sign-out so the next user does not see stale farm overrides"
  artifacts:
    - path: "src/hooks/useRoleChangeDetector.ts"
      provides: "Hook that detects server-side role changes via PowerSync reactive query"
      min_lines: 20
    - path: "src/components/AppLayout.tsx"
      provides: "AppLayout with useRoleChangeDetector wired in"
      contains: "useRoleChangeDetector"
    - path: "src/lib/AuthProvider.tsx"
      provides: "AuthProvider signOut clearing activeFarmStore"
      contains: "clearOverride"
  key_links:
    - from: "src/hooks/useRoleChangeDetector.ts"
      to: "src/hooks/useUserRole.ts"
      via: "useUserRole() reactive query monitoring role changes"
      pattern: "useUserRole\\(\\)"
    - from: "src/hooks/useRoleChangeDetector.ts"
      to: "src/lib/powersync.ts"
      via: "disconnectAndClear() on role change"
      pattern: "disconnectAndClear"
    - from: "src/lib/AuthProvider.tsx"
      to: "src/stores/activeFarmStore.ts"
      via: "clearOverride() in signOut flow"
      pattern: "clearOverride"
---

<objective>
Detect server-side role changes and refresh local data, plus clean up the active farm store on sign-out.

Purpose: When a user's role is changed server-side (e.g., admin downgraded to meter_checker), their local PowerSync data may contain records they no longer have access to. Detecting the role change and triggering disconnectAndClear ensures fresh data matching the new role's sync rules. Clearing the active farm store on sign-out prevents stale farm overrides for the next user.

Output: useRoleChangeDetector.ts hook, updated AppLayout.tsx, updated AuthProvider.tsx signOut.
</objective>

<execution_context>
@C:/Users/Kis&Co/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Kis&Co/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-permission-enforcement/04-03-SUMMARY.md
@src/hooks/useUserRole.ts
@src/lib/powersync.ts
@src/components/AppLayout.tsx
@src/lib/AuthProvider.tsx
@src/stores/activeFarmStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useRoleChangeDetector hook and wire into AppLayout</name>
  <files>src/hooks/useRoleChangeDetector.ts, src/components/AppLayout.tsx</files>
  <action>
**Create `src/hooks/useRoleChangeDetector.ts`**:

```typescript
import { useEffect, useRef } from 'react';
import { useUserRole } from './useUserRole';
import { disconnectAndClear } from '../lib/powersync';
import { debugLog } from '../lib/debugLog';
import type { Role } from '../lib/permissions';

/**
 * Monitors the user's role via PowerSync reactive query and detects
 * when it changes server-side. On role change, triggers disconnectAndClear()
 * to refresh local data matching the new role's sync rules, then reloads.
 *
 * IMPORTANT: Distinguishes "initial load" (null -> role) from "actual change"
 * (role A -> role B) to prevent infinite reload loops on app startup.
 */
export function useRoleChangeDetector(): void {
  const role = useUserRole();
  const prevRoleRef = useRef<Role | null | undefined>(undefined);

  useEffect(() => {
    // First render: store initial value, do nothing
    if (prevRoleRef.current === undefined) {
      prevRoleRef.current = role;
      return;
    }

    // Only trigger on known-role to different-known-role transitions
    // null -> role = initial load (skip)
    // role -> null = sign out or data clearing (skip)
    // role A -> role A = no change (skip)
    // role A -> role B = actual role change (trigger!)
    if (
      prevRoleRef.current !== null &&
      role !== null &&
      prevRoleRef.current !== role
    ) {
      debugLog('RoleChangeDetector', `Role changed from ${prevRoleRef.current} to ${role}, clearing local data`);

      disconnectAndClear().then(() => {
        // Full page reload ensures all state (Zustand, contexts, PowerSync) resets cleanly.
        // Role changes are rare events -- a reload is acceptable UX.
        window.location.reload();
      });
    }

    prevRoleRef.current = role;
  }, [role]);
}
```

Key design decisions:
- `useRef<Role | null | undefined>(undefined)` -- `undefined` means "haven't seen any value yet", distinct from `null` (no role data)
- Only triggers on `known -> different known` transitions, preventing infinite reload on startup
- Uses `window.location.reload()` per research recommendation -- simplest and most reliable for rare events
- `disconnectAndClear()` sets PowerSync instance to null, reload triggers fresh `setupPowerSync()` in provider

**Update `src/components/AppLayout.tsx`**:

1. Import `useRoleChangeDetector` from `../hooks/useRoleChangeDetector`
2. Call `useRoleChangeDetector()` inside the `AppLayoutContent` component (NOT in `AppLayout` -- it must be inside PowerSyncProvider to use PowerSync queries):

```typescript
function AppLayoutContent() {
  // ... existing state and hooks
  useRoleChangeDetector(); // Monitor for server-side role changes

  // ... rest of component unchanged
}
```

Place the hook call near the top of the component, after existing state declarations. The hook has no return value (void) -- it only produces side effects.
  </action>
  <verify>Run `npx tsc -b --noEmit` -- zero type errors. Confirm useRoleChangeDetector.ts uses `useRef<Role | null | undefined>(undefined)` pattern (three-state ref). Confirm AppLayout.tsx calls `useRoleChangeDetector()` inside `AppLayoutContent` (within PowerSyncProvider scope). Grep for `prevRoleRef.current === undefined` to confirm initial-load guard exists.</verify>
  <done>useRoleChangeDetector hook created with safe initial-load handling. Wired into AppLayout inside PowerSyncProvider scope. Transitions from one known role to a different known role trigger disconnectAndClear + reload. No infinite reload loops on startup.</done>
</task>

<task type="auto">
  <name>Task 2: Clear active farm store on sign-out in AuthProvider</name>
  <files>src/lib/AuthProvider.tsx</files>
  <action>
Update `src/lib/AuthProvider.tsx` to clear the active farm Zustand store during sign-out. This prevents the pitfall where a super admin selects Farm B, signs out, and the next user inherits the Farm B override.

1. Import the store: `import { useActiveFarmStore } from '../stores/activeFarmStore';`

2. In the `signOut` callback, add `useActiveFarmStore.getState().clearOverride()` AFTER the PowerSync disconnect and BEFORE clearing local state. The store is accessed via `getState()` (not a hook) because this is inside a callback, not a component render:

```typescript
const signOut = useCallback(async (): Promise<void> => {
  userInitiatedSignOut.current = true;

  try {
    await supabase.auth.signOut();
  } catch (error) {
    debugError('Auth', 'Sign out error:', error);
  }

  try {
    await disconnectAndClear();
  } catch (error) {
    debugError('Auth', 'Failed to clear PowerSync:', error);
  }

  // Clear active farm override (prevents stale state for next user)
  useActiveFarmStore.getState().clearOverride();

  // Clear onboarding status cache BEFORE state setters
  try {
    localStorage.removeItem(ONBOARDING_CACHE_KEY);
  } catch {
    // Non-critical
  }

  // Clear local state
  setSession(null);
  setUser(null);
  setOnboardingStatus(null);

  userInitiatedSignOut.current = false;
}, []);
```

Key points:
- Use `useActiveFarmStore.getState().clearOverride()` -- Zustand stores can be accessed outside of React components via `getState()`. This is the standard Zustand pattern for callbacks.
- Place AFTER disconnectAndClear (PowerSync cleanup) and BEFORE localStorage cleanup (ordering matches existing cleanup flow: Supabase -> PowerSync -> stores -> cache -> state).
- The `signOut` callback's dependency array remains `[]` (empty) because `useActiveFarmStore.getState` is a stable reference from Zustand.
  </action>
  <verify>Run `npx tsc -b --noEmit` -- zero type errors. Search AuthProvider.tsx for `clearOverride` -- should appear once in the signOut callback. Confirm the import of `useActiveFarmStore` is at the top of the file. Confirm `getState()` is used (not a hook call inside the callback).</verify>
  <done>AuthProvider signOut clears the active farm store override. Next user after sign-out starts with no farm override. Zustand store accessed correctly via getState() pattern.</done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with zero errors
2. useRoleChangeDetector.ts correctly distinguishes initial load from role change (undefined -> null -> role transitions)
3. AppLayout.tsx calls useRoleChangeDetector() inside AppLayoutContent (within PowerSyncProvider)
4. AuthProvider.tsx signOut calls useActiveFarmStore.getState().clearOverride()
5. No circular dependencies introduced
6. `npx vite build` succeeds
</verification>

<success_criteria>
- Role change from admin to meter_checker triggers disconnectAndClear + page reload
- Initial app load (null -> role) does NOT trigger disconnectAndClear
- Sign-out -> sign-in as different user does NOT show previous user's farm override
- TypeScript compiles and Vite builds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-permission-enforcement/04-04-SUMMARY.md`
</output>
