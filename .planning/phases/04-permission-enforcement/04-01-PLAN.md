---
phase: 04-permission-enforcement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/RequireRole.tsx
  - src/App.tsx
  - src/components/SideMenu.tsx
autonomous: true

must_haves:
  truths:
    - "Unauthorized route access (e.g., meter_checker navigating to /subscription via URL) redirects to dashboard with no error"
    - "Meter checker cannot see the Subscription nav item in the side menu"
    - "All roles can still see Map, Well List, Reports, Language, and Settings nav items"
  artifacts:
    - path: "src/components/RequireRole.tsx"
      provides: "Route guard wrapper component checking permissions via hasPermission()"
      min_lines: 20
    - path: "src/App.tsx"
      provides: "Route tree with RequireRole wrapping /subscription"
      contains: "RequireRole"
    - path: "src/components/SideMenu.tsx"
      provides: "Navigation items filtered by user role"
      contains: "requiredAction"
  key_links:
    - from: "src/components/RequireRole.tsx"
      to: "src/lib/permissions.ts"
      via: "hasPermission(role, action) call"
      pattern: "hasPermission\\(role"
    - from: "src/components/RequireRole.tsx"
      to: "src/hooks/useUserRole.ts"
      via: "useUserRole() hook call"
      pattern: "useUserRole\\(\\)"
    - from: "src/components/SideMenu.tsx"
      to: "src/lib/permissions.ts"
      via: "hasPermission() filtering navItems"
      pattern: "hasPermission\\(.*requiredAction"
---

<objective>
Create the RequireRole route guard component and wire it into the route tree, plus filter navigation items by role in SideMenu.

Purpose: This is the foundational access control layer. Once route guards and nav filtering exist, unauthorized users are silently redirected and never see nav items they cannot access.

Output: RequireRole.tsx component, updated App.tsx route tree, updated SideMenu.tsx with role-filtered navigation.
</objective>

<execution_context>
@C:/Users/Kis&Co/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Kis&Co/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/RequireAuth.tsx
@src/components/RequireOnboarded.tsx
@src/App.tsx
@src/components/SideMenu.tsx
@src/lib/permissions.ts
@src/hooks/useUserRole.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RequireRole route guard component and wire into App.tsx</name>
  <files>src/components/RequireRole.tsx, src/App.tsx</files>
  <action>
Create `src/components/RequireRole.tsx` following the EXACT same pattern as RequireAuth.tsx:

```typescript
interface RequireRoleProps {
  action: Action;           // from src/lib/permissions.ts
  fallbackPath?: string;    // default: '/'
  children?: React.ReactNode;
}
```

Implementation rules:
- Import `useUserRole` from `../hooks/useUserRole`, `hasPermission` and `Action` type from `../lib/permissions`
- Import `Navigate`, `Outlet` from `react-router`
- When `role === null`: return `null` (renders nothing while PowerSync loads). Do NOT redirect on null -- this avoids false redirects during data loading. RequireOnboarded already ensures farm membership upstream.
- When `!hasPermission(role, action)`: return `<Navigate to={fallbackPath} replace />`. No error messages, no toasts -- success criterion #4 says "redirects to dashboard with no error."
- When authorized: return `children ? <>{children}</> : <Outlet />`
- Export as default.

Then update `src/App.tsx`:
- Import RequireRole at the top with other layout components
- Wrap the `/subscription` route with `<RequireRole action="manage_farm">`:
  ```tsx
  <Route element={<RequireRole action="manage_farm" />}>
    <Route path="/subscription" element={<SubscriptionPage />} />
  </Route>
  ```
- Do NOT wrap `/settings` -- it is accessible to all roles (sections are gated within SettingsPage already by `isAdminOrAbove()`).
- Do NOT wrap `/`, `/wells`, `/reports`, `/language` -- these are accessible to all roles per the route-permission mapping in research.
- Keep RequireRole INSIDE the AppLayout route group (it needs PowerSync for useUserRole).
  </action>
  <verify>Run `npx tsc -b --noEmit` -- zero type errors. Visually inspect App.tsx to confirm RequireRole wraps only /subscription. Confirm RequireRole.tsx follows the same structural pattern as RequireAuth.tsx (props interface, three-branch return: loading/unauthorized/authorized).</verify>
  <done>RequireRole component exists, /subscription route is guarded by `manage_farm` action, all other routes remain unguarded. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Filter SideMenu navigation items by user role</name>
  <files>src/components/SideMenu.tsx</files>
  <action>
Update `src/components/SideMenu.tsx` to filter navigation items based on the user's role:

1. Add imports: `useUserRole` from `../hooks/useUserRole`, `hasPermission` from `../lib/permissions`, `type Action` from `../lib/permissions`.

2. Add `requiredAction` to the navItems type and array:
```typescript
interface NavItem {
  label: string;
  icon: React.ComponentType<{ className?: string }>;
  path: string;
  requiredAction?: Action; // undefined = visible to all roles
}
```

3. Update the `navItems` array -- add `requiredAction` ONLY to items that need gating:
```typescript
const navItems: NavItem[] = [
  { label: 'Map', icon: MapIcon, path: '/' },
  { label: 'Well List', icon: ListBulletIcon, path: '/wells' },
  { label: 'Reports', icon: ChartBarIcon, path: '/reports' },
  { label: 'Subscription', icon: CreditCardIcon, path: '/subscription', requiredAction: 'manage_farm' },
  { label: 'Language', icon: GlobeAltIcon, path: '/language' },
  { label: 'Settings', icon: Cog6ToothIcon, path: '/settings' },
];
```

Only `Subscription` gets `requiredAction: 'manage_farm'` (restricts to super_admin and grower). Settings is accessible to ALL roles (sections gated inside SettingsPage). Map, Well List, Reports, Language are universal.

4. Inside the component, get the role and filter:
```typescript
const role = useUserRole();
const visibleItems = navItems.filter(
  (item) => !item.requiredAction || hasPermission(role, item.requiredAction)
);
```

5. Replace `navItems.map(...)` with `visibleItems.map(...)` in the JSX.

Use the same `requiredAction` action string (`'manage_farm'`) that the RequireRole guard uses for `/subscription` in App.tsx. This ensures nav visibility and route protection use the same permission check -- preventing the pitfall of nav items being out of sync with route guards.
  </action>
  <verify>Run `npx tsc -b --noEmit` -- zero type errors. Count navItems in the array: should be 6. Confirm only Subscription has `requiredAction`. Confirm `visibleItems` is used in the render, not `navItems`.</verify>
  <done>SideMenu filters nav items by role. Meter checker and admin do not see "Subscription" in the menu. Grower and super_admin see all items. All roles see Map, Well List, Reports, Language, Settings.</done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with zero errors
2. RequireRole.tsx exists with correct three-branch logic (null return for loading, Navigate for unauthorized, Outlet for authorized)
3. App.tsx imports RequireRole and wraps only /subscription
4. SideMenu.tsx imports useUserRole and hasPermission, filters navItems by requiredAction
5. The same action string 'manage_farm' is used in both RequireRole (App.tsx) and SideMenu navItems for /subscription
</verification>

<success_criteria>
- RequireRole component created following RequireAuth pattern exactly
- /subscription route guarded by manage_farm action
- SideMenu filters Subscription nav item for non-grower/non-super_admin roles
- Navigation filtering and route guards use identical permission actions (no sync mismatch)
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-permission-enforcement/04-01-SUMMARY.md`
</output>
