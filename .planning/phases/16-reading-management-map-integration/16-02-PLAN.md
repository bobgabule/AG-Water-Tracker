---
phase: 16-reading-management-map-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useCurrentAllocations.ts
  - src/hooks/useLatestReadings.ts
  - src/components/WellMarker.tsx
  - src/components/MapView.tsx
  - src/pages/DashboardPage.tsx
  - src/pages/WellListPage.tsx
autonomous: true
requirements:
  - WELL-10
  - WELL-11

must_haves:
  truths:
    - "WellMarker gauge on the map shows real allocation usage percentage instead of hardcoded 100%"
    - "Wells with no allocation show an empty gauge (0%)"
    - "Well list page shows the date of the latest reading for each well"
    - "Wells with no readings show 'No readings' on the well list"
    - "Allocation and reading data updates reactively via PowerSync"
  artifacts:
    - path: "src/hooks/useCurrentAllocations.ts"
      provides: "Batch query for current allocation per well"
      exports: ["useCurrentAllocations"]
    - path: "src/hooks/useLatestReadings.ts"
      provides: "Batch query for latest reading date per well"
      exports: ["useLatestReadings"]
    - path: "src/components/WellMarker.tsx"
      provides: "Map marker with real allocation percentage gauge"
      exports: ["default"]
    - path: "src/components/MapView.tsx"
      provides: "Map view passing allocation data to markers"
      exports: ["default"]
    - path: "src/pages/WellListPage.tsx"
      provides: "Well list with actual latest reading dates"
      exports: ["default"]
  key_links:
    - from: "src/hooks/useCurrentAllocations.ts"
      to: "src/components/MapView.tsx"
      via: "allocationsByWellId map passed to WellMarker"
      pattern: "useCurrentAllocations(farmId)"
    - from: "src/hooks/useLatestReadings.ts"
      to: "src/pages/WellListPage.tsx"
      via: "latestByWellId map used in computeWellDisplayData"
      pattern: "useLatestReadings(farmId)"
---

<objective>
Replace hardcoded map marker gauges with real allocation data and show latest reading dates on the well list.

Purpose: Map markers currently show 100% gauge (hardcoded) regardless of actual allocation usage. The well list shows the well's last-modified timestamp rather than when a reading was actually recorded. This plan provides accurate, live data in both views.

Output: Two new hooks (useCurrentAllocations, useLatestReadings), updated WellMarker accepting real percentage, updated MapView and DashboardPage passing allocation data, and updated WellListPage using reading dates.
</objective>

<execution_context>
@C:/Users/Kis&Co/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Kis&Co/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/WellMarker.tsx
@src/components/MapView.tsx
@src/pages/DashboardPage.tsx
@src/pages/WellListPage.tsx
@src/hooks/useWellAllocations.ts
@src/hooks/useWells.ts
@src/components/WellUsageGauge.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useCurrentAllocations hook and update WellMarker + MapView</name>
  <files>src/hooks/useCurrentAllocations.ts, src/components/WellMarker.tsx, src/components/MapView.tsx, src/pages/DashboardPage.tsx</files>
  <action>
**1. Create `src/hooks/useCurrentAllocations.ts`:**

Batch query fetching the current allocation for every well in the farm. "Current" = today's date falls within period_start and period_end.

```typescript
import { useMemo } from 'react';
import { useQuery } from '@powersync/react';

interface CurrentAllocationRow {
  well_id: string;
  allocated_af: string;
  used_af: string;
}

export interface WellAllocationSummary {
  allocatedAf: number;
  usedAf: number;
  usagePercent: number;
}

export function useCurrentAllocations(farmId: string | null) {
  const today = useMemo(() => new Date().toISOString().split('T')[0], []);

  const query = farmId
    ? `SELECT well_id, allocated_af, used_af
       FROM allocations
       WHERE farm_id = ? AND period_start <= ? AND period_end >= ?
       ORDER BY period_start DESC`
    : 'SELECT NULL WHERE 0';

  const { data, isLoading } = useQuery<CurrentAllocationRow>(
    query,
    farmId ? [farmId, today, today] : [],
  );

  const allocationsByWellId = useMemo(() => {
    const map = new Map<string, WellAllocationSummary>();
    for (const row of data ?? []) {
      if (map.has(row.well_id)) continue; // first row wins (most recent period)
      const allocated = parseFloat(row.allocated_af) || 0;
      const used = parseFloat(row.used_af) || 0;
      const usagePercent = allocated > 0
        ? Math.min((used / allocated) * 100, 100)
        : 0;
      map.set(row.well_id, { allocatedAf: allocated, usedAf: used, usagePercent });
    }
    return map;
  }, [data]);

  return { allocationsByWellId, loading: isLoading };
}
```

Key: Single query for all wells, returns `Map<wellId, WellAllocationSummary>` for O(1) lookup per marker. Guard query when no farmId. Memoized result.

**2. Update `src/components/WellMarker.tsx`:**

Add optional prop to the interface:
```typescript
interface WellMarkerProps {
  well: WellWithReading;
  allocationPercentage?: number;
  onClick?: (wellId: string) => void;
}
```

Replace line 65-66:
```typescript
// Future: calculate from used / allocated
const allocationPercentage = 100;
```
With:
```typescript
const fillPercent = allocationPercentage ?? 0;
```

Update the gauge style at line 99:
```tsx
style={{ height: `${fillPercent}%` }}
```

Add `allocationPercentage` to the destructured props in the function signature.

**3. Update `src/components/MapView.tsx`:**

Add `farmId` to the props interface:
```typescript
interface MapViewProps {
  wells: WellWithReading[];
  farmState?: string | null;
  farmId?: string | null;
  onWellClick?: (wellId: string) => void;
  onMapClick?: (lngLat: { lng: number; lat: number }) => void;
  pickedLocation?: { latitude: number; longitude: number } | null;
  isPickingLocation?: boolean;
}
```

Import and call the hook:
```typescript
import { useCurrentAllocations } from '../hooks/useCurrentAllocations';
// Inside the component:
const { allocationsByWellId } = useCurrentAllocations(farmId ?? null);
```

Update the WellMarker rendering (line 235-239):
```tsx
{wells
  .filter((w) => w.location)
  .map((well) => (
    <WellMarker
      key={well.id}
      well={well}
      allocationPercentage={allocationsByWellId.get(well.id)?.usagePercent}
      onClick={onWellClick}
    />
  ))}
```

**4. Update `src/pages/DashboardPage.tsx`:**

Pass farmId to MapView (add to the existing MapView JSX, around line 149-157):
```tsx
<MapView
  key={mapKey}
  wells={wells}
  farmState={farmState}
  farmId={farmId}
  onWellClick={handleWellClick}
  onMapClick={handleMapClick}
  pickedLocation={pickedLocation}
  isPickingLocation={currentStep === 'location'}
/>
```

`farmId` is already available on line 25: `const farmId = onboardingStatus?.farmId ?? null;`
  </action>
  <verify>Run `npx tsc -b --noEmit` to confirm no type errors. Verify WellMarker no longer has hardcoded 100. Verify MapView passes allocationPercentage to each WellMarker. Verify DashboardPage passes farmId to MapView.</verify>
  <done>WellMarker gauge shows real allocation usage percentage. Wells with allocations show their used/allocated ratio. Wells without allocations show empty gauge (0%). Data updates reactively via PowerSync.</done>
</task>

<task type="auto">
  <name>Task 2: Create useLatestReadings hook and update WellListPage</name>
  <files>src/hooks/useLatestReadings.ts, src/pages/WellListPage.tsx</files>
  <action>
**1. Create `src/hooks/useLatestReadings.ts`:**

Batch query fetching the latest reading timestamp per well for the entire farm.

```typescript
import { useMemo } from 'react';
import { useQuery } from '@powersync/react';

interface LatestReadingRow {
  well_id: string;
  latest_recorded_at: string;
}

export function useLatestReadings(farmId: string | null) {
  const query = farmId
    ? `SELECT well_id, MAX(recorded_at) as latest_recorded_at
       FROM readings
       WHERE farm_id = ?
       GROUP BY well_id`
    : 'SELECT NULL WHERE 0';

  const { data, isLoading } = useQuery<LatestReadingRow>(
    query,
    farmId ? [farmId] : [],
  );

  const latestByWellId = useMemo(() => {
    const map = new Map<string, string>();
    for (const row of data ?? []) {
      if (row.well_id && row.latest_recorded_at) {
        map.set(row.well_id, row.latest_recorded_at);
      }
    }
    return map;
  }, [data]);

  return { latestByWellId, loading: isLoading };
}
```

Key: `MAX(recorded_at) GROUP BY well_id` gives one result per well in a single query. Returns `Map<wellId, isoTimestamp>`.

**2. Update `src/pages/WellListPage.tsx`:**

Import the hook and auth:
```typescript
import { useLatestReadings } from '../hooks/useLatestReadings';
import { useAuth } from '../lib/AuthProvider';
```

Get farmId and call hook inside the component:
```typescript
const { onboardingStatus } = useAuth();
const farmId = onboardingStatus?.farmId ?? null;
const { latestByWellId } = useLatestReadings(farmId);
```

Modify `computeWellDisplayData` signature to accept the latest reading date:
```typescript
function computeWellDisplayData(
  well: WellWithReading,
  latestReadingDate: string | null,
): WellDisplayData {
```

Inside the function, replace `const { updatedAt, status } = well;` with:
```typescript
const { status } = well;
const dateToUse = latestReadingDate; // Use actual reading date, NOT well.updatedAt
```

Replace all references to `updatedAt` with `dateToUse` in the function body. When `dateToUse` is null (no readings), `diffDays` will be null and `formattedTime` will be "No readings" â€” this is correct behavior.

Update the `wellsWithDisplayData` memo to pass the reading date:
```typescript
const wellsWithDisplayData = useMemo(
  () => wells.map((well) =>
    computeWellDisplayData(well, latestByWellId.get(well.id) ?? null)
  ),
  [wells, latestByWellId],
);
```
  </action>
  <verify>Run `npx tsc -b --noEmit` to confirm no type errors. Verify useLatestReadings returns a Map. Verify WellListPage uses latestByWellId instead of well.updatedAt. Verify wells with no readings show "No readings".</verify>
  <done>Well list page shows the actual latest reading date per well. Wells with readings show relative time ("Today", "3 days ago"). Wells without readings show "No readings". Data updates reactively when new readings are recorded.</done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with no errors
2. Map markers show real usage percentage gauge:
   - Well with 50% allocation used = tube half-filled with blue
   - Well with no allocation = empty tube (0% fill)
   - Well with 100% usage = full tube
3. Well list shows actual latest reading date:
   - Well with reading from today shows "Today"
   - Well with reading from 5 days ago shows "5 days ago"
   - Well with no readings shows "No readings"
4. Adding a new reading reactively updates both the map gauge and well list date
</verification>

<success_criteria>
- WellMarker gauge reflects real allocation usage (not hardcoded 100%)
- Wells without allocations show empty gauge
- Well list uses actual reading dates instead of well.updatedAt
- Wells without readings show "No readings"
- Both hooks use efficient single-query patterns with memoized Maps
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-reading-management-map-integration/16-02-SUMMARY.md`
</output>
