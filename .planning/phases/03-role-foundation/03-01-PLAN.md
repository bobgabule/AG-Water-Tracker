---
phase: 03-role-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/permissions.ts
  - src/hooks/useUserRole.ts
autonomous: true

must_haves:
  truths:
    - "A centralized TypeScript module defines the four roles and all actions, with a hasPermission() function that checks role against action"
    - "A useUserRole hook queries the current user's role from PowerSync farm_members table and returns a typed Role or null"
    - "No client code needs to hardcode role strings -- all checks go through the permission module"
  artifacts:
    - path: "src/lib/permissions.ts"
      provides: "Role type, Action type, ROLES constant, PERMISSION_MATRIX, hasPermission(), isAdminOrAbove()"
      exports: ["Role", "Action", "ROLES", "hasPermission", "isAdminOrAbove", "ROLE_DISPLAY_NAMES"]
    - path: "src/hooks/useUserRole.ts"
      provides: "useUserRole hook returning current user's role from farm_members"
      exports: ["useUserRole"]
  key_links:
    - from: "src/hooks/useUserRole.ts"
      to: "src/lib/permissions.ts"
      via: "imports Role type"
      pattern: "import.*Role.*from.*permissions"
    - from: "src/hooks/useUserRole.ts"
      to: "@powersync/react"
      via: "useQuery for farm_members role lookup"
      pattern: "useQuery.*SELECT role FROM farm_members"
---

<objective>
Create the centralized TypeScript permission matrix and useUserRole hook that all client-side role checking will depend on.

Purpose: Establishes the single source of truth for role definitions and permission checks so that no component ever hardcodes role strings. This is the foundation that Phase 4 (Permission Enforcement) builds on.
Output: `src/lib/permissions.ts` and `src/hooks/useUserRole.ts`
</objective>

<execution_context>
@C:/Users/Bobits/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bobits/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-role-foundation/03-RESEARCH.md

Key references:
- `src/hooks/useUserProfile.ts` — Follow this pattern for useUserRole (same useQuery + useMemo + guard pattern)
- `src/lib/AuthProvider.tsx` — useAuth() provides `user` and `onboardingStatus` (needed for userId and farmId)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create permission matrix module</name>
  <files>src/lib/permissions.ts</files>
  <action>
Create `src/lib/permissions.ts` with the following:

1. **Role type** as a string literal union (NOT enum -- avoids runtime overhead):
   ```typescript
   export const ROLES = ['super_admin', 'grower', 'admin', 'meter_checker'] as const;
   export type Role = (typeof ROLES)[number];
   ```

2. **Action type** as a string literal union covering all gatable actions:
   - `manage_farm` (edit farm settings)
   - `manage_users` (invite, disable, enable users)
   - `manage_wells` (edit, delete wells)
   - `create_well` (add new well)
   - `record_reading` (submit meter readings)
   - `view_wells` (see well list and map)
   - `view_members` (see team members)
   - `manage_invites` (create/revoke invite codes)
   - `cross_farm_access` (see other farms -- super_admin only)

3. **PERMISSION_MATRIX** as `Record<Role, Set<Action>>`:
   - `super_admin`: ALL actions including `cross_farm_access`
   - `grower`: ALL actions EXCEPT `cross_farm_access`
   - `admin`: `manage_users`, `manage_wells`, `create_well`, `record_reading`, `view_wells`, `view_members`, `manage_invites` (NOT `manage_farm`, NOT `cross_farm_access`)
   - `meter_checker`: `record_reading`, `view_wells`, `view_members` only

4. **hasPermission(role, action)**: Returns boolean. Returns false for null/undefined role.

5. **isAdminOrAbove(role)**: Returns true for `super_admin`, `grower`, `admin`. Returns false for `meter_checker`, null, undefined. This replaces scattered `role === 'owner' || role === 'admin'` checks.

6. **ROLE_DISPLAY_NAMES**: A `Record<Role, string>` mapping for UI display:
   - `super_admin` -> "Super Admin"
   - `grower` -> "Grower"
   - `admin` -> "Admin"
   - `meter_checker` -> "Meter Checker"
  </action>
  <verify>Run `npx tsc -b --noEmit` -- no type errors in the new file.</verify>
  <done>permissions.ts exports Role, Action, ROLES, hasPermission, isAdminOrAbove, ROLE_DISPLAY_NAMES. All types are narrow (no `string`), no runtime dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Create useUserRole hook</name>
  <files>src/hooks/useUserRole.ts</files>
  <action>
Create `src/hooks/useUserRole.ts` following the exact same pattern as `src/hooks/useUserProfile.ts`:

1. Import `useMemo` from React, `useQuery` from `@powersync/react`, `useAuth` from `../lib/AuthProvider`, and `Role` type from `../lib/permissions`.

2. Define a `RoleRow` interface with `role: string`.

3. The hook:
   - Gets `user` and `onboardingStatus` from `useAuth()`
   - Derives `userId` from `user?.id ?? null` and `farmId` from `onboardingStatus?.farmId ?? null`
   - Guards empty queries: if no userId or farmId, use `'SELECT NULL WHERE 0'`
   - Otherwise queries: `'SELECT role FROM farm_members WHERE user_id = ? AND farm_id = ?'`
   - Wraps result in `useMemo`: if no data, return null; otherwise return `data[0].role as Role`
   - Return type is `Role | null`

4. Export `useUserRole` as a named export.

The hook MUST NOT return role from the `users` table. The authoritative source is `farm_members.role`. This is a deliberate separation from `useUserProfile` (which reads `users` table).
  </action>
  <verify>Run `npx tsc -b --noEmit` -- no type errors. Verify useUserRole follows the same guard pattern as useUserProfile (check `'SELECT NULL WHERE 0'` guard exists).</verify>
  <done>useUserRole hook returns Role | null from farm_members table. It uses the same guarded query pattern as useUserProfile. It imports Role from permissions.ts.</done>
</task>

</tasks>

<verification>
1. `npx tsc -b --noEmit` passes with no errors
2. `src/lib/permissions.ts` exports: Role, Action, ROLES, hasPermission, isAdminOrAbove, ROLE_DISPLAY_NAMES
3. `src/hooks/useUserRole.ts` exports: useUserRole
4. `hasPermission('meter_checker', 'manage_users')` returns false
5. `hasPermission('grower', 'manage_farm')` returns true
6. `isAdminOrAbove('meter_checker')` returns false
7. `isAdminOrAbove('admin')` returns true
</verification>

<success_criteria>
- Permission matrix module exists with complete role/action definitions
- useUserRole hook follows established codebase patterns (guarded query, useMemo)
- TypeScript compilation passes with no errors
- No hardcoded role strings needed by consumers -- they import from permissions.ts
</success_criteria>

<output>
After completion, create `.planning/phases/03-role-foundation/03-01-SUMMARY.md`
</output>
