---
phase: 03-role-foundation
plan: 04
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - supabase/migrations/022_custom_access_token_hook.sql
autonomous: false

must_haves:
  truths:
    - "A custom_access_token_hook function exists in public schema that injects user_role and farm_id into JWT app_metadata claims"
    - "supabase_auth_admin has EXECUTE permission on the hook and SELECT on farm_members"
    - "authenticated, anon, and public roles CANNOT execute the hook function directly"
    - "The hook returns event unchanged (with null claims) when the user has no farm membership"
    - "The hook selects the user's primary farm (earliest created_at) when they have multiple memberships"
  artifacts:
    - path: "supabase/migrations/022_custom_access_token_hook.sql"
      provides: "Custom Access Token Hook function with grants and policies"
      contains: "custom_access_token_hook"
  key_links:
    - from: "custom_access_token_hook()"
      to: "farm_members"
      via: "SELECT role, farm_id with ORDER BY created_at ASC LIMIT 1"
      pattern: "FROM.*farm_members.*WHERE.*user_id.*ORDER BY.*created_at"
    - from: "custom_access_token_hook()"
      to: "JWT claims"
      via: "jsonb_set into app_metadata.user_role and app_metadata.farm_id"
      pattern: "jsonb_set.*app_metadata.*user_role"

user_setup:
  - service: supabase
    why: "Custom Access Token Hook must be manually enabled in Supabase Dashboard"
    dashboard_config:
      - task: "Enable Custom Access Token Hook"
        location: "Supabase Dashboard -> Authentication -> Hooks -> Custom Access Token"
        details: "Select the custom_access_token_hook function from the dropdown and enable it. Test by logging in and inspecting the JWT claims."
---

<objective>
Create the Custom Access Token Hook that injects role and farm_id into JWT claims, enabling PowerSync sync rules and future RLS optimizations to read role from the token.

Purpose: The hook runs automatically on every token issuance (login, refresh). PowerSync sync rules can then use `request.jwt() ->> 'app_metadata.farm_id'` instead of querying farm_members at sync time. This is the bridge between the database role system and the sync layer.
Output: `supabase/migrations/022_custom_access_token_hook.sql`
</objective>

<execution_context>
@C:/Users/Bobits/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bobits/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-role-foundation/03-RESEARCH.md
@.planning/phases/03-role-foundation/03-02-SUMMARY.md

Key references:
- `supabase/migrations/020_security_definer_private_schema.sql` â€” Private schema pattern (but hook MUST be in public schema per Supabase requirement)
- Supabase docs: Custom Access Token Hook requires the function to be in public schema and callable by supabase_auth_admin
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Custom Access Token Hook migration</name>
  <files>supabase/migrations/022_custom_access_token_hook.sql</files>
  <action>
Create `supabase/migrations/022_custom_access_token_hook.sql` with:

**Section 1: The hook function**

```sql
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  claims jsonb;
  v_user_id uuid;
  v_role text;
  v_farm_id uuid;
BEGIN
  v_user_id := (event->>'user_id')::uuid;

  -- Get user's primary farm membership (first farm joined)
  SELECT fm.role, fm.farm_id
  INTO v_role, v_farm_id
  FROM public.farm_members fm
  WHERE fm.user_id = v_user_id
  ORDER BY fm.created_at ASC
  LIMIT 1;

  claims := event->'claims';

  -- Ensure app_metadata exists in claims
  IF jsonb_typeof(claims->'app_metadata') IS NULL THEN
    claims := jsonb_set(claims, '{app_metadata}', '{}');
  END IF;

  -- Inject role and farm_id into app_metadata
  IF v_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{app_metadata, user_role}', to_jsonb(v_role));
    claims := jsonb_set(claims, '{app_metadata, farm_id}', to_jsonb(v_farm_id::text));
  ELSE
    -- User has no farm membership yet (e.g., during onboarding)
    claims := jsonb_set(claims, '{app_metadata, user_role}', 'null');
    claims := jsonb_set(claims, '{app_metadata, farm_id}', 'null');
  END IF;

  event := jsonb_set(event, '{claims}', claims);
  RETURN event;
END;
$$;
```

**Important:** The function is NOT SECURITY DEFINER. It does not use `SET search_path = ''` because it needs access to `public.farm_members`. Supabase Auth calls it with supabase_auth_admin privileges, which we grant below.

**Section 2: Permission grants**

```sql
-- Grant schema access to supabase_auth_admin
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;

-- Allow auth admin to execute the hook
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;

-- Prevent direct invocation by regular users (security: they should NOT be able to call this)
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;

-- Allow the hook to read farm_members (supabase_auth_admin needs SELECT)
GRANT SELECT ON TABLE public.farm_members TO supabase_auth_admin;
```

**Section 3: RLS policy for supabase_auth_admin**

```sql
-- supabase_auth_admin needs to bypass RLS on farm_members to look up the user's role
CREATE POLICY "Allow auth admin to read farm_members"
    ON farm_members AS PERMISSIVE FOR SELECT
    TO supabase_auth_admin USING (true);
```

**Section 4: Add a header comment block** explaining:
- What the hook does (injects role and farm_id into JWT claims)
- Why it's in public schema (Supabase Auth Hook requirement)
- That it must be manually enabled in Supabase Dashboard -> Authentication -> Hooks
- The claims path: `app_metadata.user_role` and `app_metadata.farm_id`
- That tokens are refreshed ~every hour, so role changes take up to 1 hour to reflect in JWT
  </action>
  <verify>
1. Read the migration file and verify: function signature matches Supabase hook contract (takes jsonb, returns jsonb)
2. Verify GRANT/REVOKE block is complete (EXECUTE to supabase_auth_admin, REVOKE from authenticated/anon/public)
3. Verify RLS policy for supabase_auth_admin exists
4. Run `npx tsc -b --noEmit` (no client code changes, should still pass)
  </verify>
  <done>Migration 022 creates the Custom Access Token Hook with proper grants and RLS policy. The function is safe to deploy -- it won't run until manually enabled in the Supabase Dashboard.</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: Enable Custom Access Token Hook in Supabase Dashboard</name>
  <files>N/A (dashboard configuration)</files>
  <action>
This is a manual step that cannot be automated. The Custom Access Token Hook SQL function has been created via migration 022 but must be manually enabled in the Supabase Dashboard:

1. Apply migration 022 to your Supabase database (if not already done via `supabase db push` or migration tool)
2. Go to **Supabase Dashboard** -> **Authentication** -> **Hooks**
3. Find **Custom Access Token** hook
4. Enable it and select `custom_access_token_hook` from the function dropdown
5. Save the configuration
  </action>
  <verify>
1. Log out and log back in to the app
2. Inspect the JWT token (browser DevTools -> Application -> Local Storage -> look for `sb-*-auth-token`)
3. Decode the JWT at jwt.io and verify `app_metadata` contains `user_role` and `farm_id`

Expected JWT claims after login:
```json
{
  "app_metadata": {
    "user_role": "grower",
    "farm_id": "your-farm-uuid"
  }
}
```

If the user has no farm membership (new user during onboarding), both values will be `null`.
  </verify>
  <done>Custom Access Token Hook is enabled in Supabase Dashboard and JWT tokens contain app_metadata.user_role and app_metadata.farm_id claims. Resume signal: type "hook enabled" to confirm, or describe any issues encountered.</done>
</task>

</tasks>

<verification>
1. Migration file exists at `supabase/migrations/022_custom_access_token_hook.sql`
2. Function signature: `custom_access_token_hook(event jsonb) RETURNS jsonb`
3. Grants: supabase_auth_admin can execute, authenticated/anon/public cannot
4. RLS policy: supabase_auth_admin can read farm_members
5. After dashboard enablement: JWT contains app_metadata.user_role and app_metadata.farm_id
</verification>

<success_criteria>
- Custom Access Token Hook migration created and ready to deploy
- Hook function correctly injects role and farm_id into JWT claims
- Permissions properly restrict who can call the function
- Dashboard hook manually enabled and verified via JWT inspection
- Users with no farm membership get null claims (not an error)
</success_criteria>

<output>
After completion, create `.planning/phases/03-role-foundation/03-04-SUMMARY.md`
</output>
